<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html data-context="Build Apps" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>le_hashmap.h File Reference - Legato Docs</title>
<meta content="legato™ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description"/>
<meta content="legato, iot" name="keywords"/>
<meta content="17.08.1" name="legato-version"/>
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<link href="resources/images/legato.ico" rel="shortcut icon"/>
<link href="resources/images/legato.ico" rel="icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="apple-touch-icon" type="image/x-icon"/>
<link href="resources/css/style.css" media="screen" rel="stylesheet" type="text/css"/>
<link href="resources/css/font-awesome.css" rel="stylesheet" type="text/css"/>
<!--[if IE]>
        <script src="resources/js/html5shiv.js"></script>
        <script src="resources/js/respond.js"></script>
        <![endif]-->
<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="resources/js/main.js"></script>
<script src="tocs/Build_Apps_API_Guides.json"></script>
</head>
<body>
<noscript>
<input class="modal-closing-trick" id="modal-closing-trick" type="checkbox"/>
<div id="nojs">
<label for="modal-closing-trick">
<span>You seem to not have Javascript <a href="http://enable-javascript.com">enabled</a>, so site functionality like the search and navigation tree won't work.</span>
</label>
</div>
</noscript>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/">Introduction</a><a class="navlink selected" href="buildAppsMain.html">Build Apps</a><a class="navlink" href="buildPlatformMain.html">Build Platform</a><a class="navlink" href="aboutMain.html">About</a>
</nav>
</header>
</div>
<div class="white" id="menudocumentation">
<header>
<a href="/"> <img alt="Back to Legato Homepage" id="logo" src="resources/images/legato_logo.png"/></a>
<h2>/ Build Apps</h2>
<nav class="secondary">
<a href="buildAppsConcepts.html">Concepts</a><a class="link-selected" href="apiGuidesMain.html">API Guides</a><a href="tools.html">Tools</a><a href="external_proj_mainpage.html">WiFi Plugin</a>
</nav>
<nav class="ui-front">
<i class="fa fa-search" id="search-icon"></i>
<input id="searchbox" placeholder="Search"/>
</nav>
</header>
</div>
<div id="resizable">
<div id="left">
<div id="tree1"></div>
</div>
</div>
<div class="content">
<div class="header">
<div class="summary">
<a href="#define-members">Macros</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<h1 class="title">le_hashmap.h File Reference</h1> </div>
</div><div class="contents">
<p><a href="le__hashmap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a88f09b10323839a1a187b2fddab3ba0b"><td align="right" class="memItemLeft" valign="top">#define </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a88f09b10323839a1a187b2fddab3ba0b">LE_HASHMAP_MAKE_HASH</a>(type)</td></tr>
<tr class="separator:a88f09b10323839a1a187b2fddab3ba0b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae81c60860dbdb8c59beaf25985e5605a"><td align="right" class="memItemLeft" valign="top">typedef struct le_hashmap * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a></td></tr>
<tr class="separator:ae81c60860dbdb8c59beaf25985e5605a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8ab2021261a368add28c1be14f248459"><td align="right" class="memItemLeft" valign="top">typedef struct le_hashmap_It * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a></td></tr>
<tr class="separator:a8ab2021261a368add28c1be14f248459"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a354b7f0a30dd40266d367351a4b248b7"><td align="right" class="memItemLeft" valign="top">typedef size_t(* </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a>) (const void *keyToHashPtr)</td></tr>
<tr class="separator:a354b7f0a30dd40266d367351a4b248b7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adfe15673aeaa2400d3147d62abffee40"><td align="right" class="memItemLeft" valign="top">typedef bool(* </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a>) (const void *firstKeyPtr, const void *secondKeyPtr)</td></tr>
<tr class="separator:adfe15673aeaa2400d3147d62abffee40"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acae181524ccab8958e1c8fd5855995b1"><td align="right" class="memItemLeft" valign="top">typedef bool(* </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a>) (const void *keyPtr, const void *valuePtr, void *contextPtr)</td></tr>
<tr class="separator:acae181524ccab8958e1c8fd5855995b1"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ade79896a5b2ceec82c570fe21f7efe3a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create</a> (const char *nameStr, size_t capacity, <a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a> hashFunc, <a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a> equalsFunc)</td></tr>
<tr class="separator:ade79896a5b2ceec82c570fe21f7efe3a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a68759fb8291c487a507eae6d92710fc7"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr, const void *valuePtr)</td></tr>
<tr class="separator:a68759fb8291c487a507eae6d92710fc7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4322a312a2e4b00112022c2cb04eb416"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a4322a312a2e4b00112022c2cb04eb416">le_hashmap_Get</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr class="separator:a4322a312a2e4b00112022c2cb04eb416"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9645e5b363c335e1dd324f536e2b754c"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a9645e5b363c335e1dd324f536e2b754c">le_hashmap_GetStoredKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr class="separator:a9645e5b363c335e1dd324f536e2b754c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64eab4c096da5b66aa54c70ec5d5a776"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a64eab4c096da5b66aa54c70ec5d5a776">le_hashmap_Remove</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr class="separator:a64eab4c096da5b66aa54c70ec5d5a776"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5530fc9656f5e49f891541900bc21f34"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a5530fc9656f5e49f891541900bc21f34">le_hashmap_isEmpty</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a5530fc9656f5e49f891541900bc21f34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a481e3fa6b0fe8319074140a2cb2ae1cc"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a481e3fa6b0fe8319074140a2cb2ae1cc">le_hashmap_Size</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a481e3fa6b0fe8319074140a2cb2ae1cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af42bc33eaed4e6183edfbded3203beb4"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#af42bc33eaed4e6183edfbded3203beb4">le_hashmap_ContainsKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr class="separator:af42bc33eaed4e6183edfbded3203beb4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27e3af23871a2f9e8adffb748111aab2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a27e3af23871a2f9e8adffb748111aab2">le_hashmap_RemoveAll</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a27e3af23871a2f9e8adffb748111aab2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b4b88ce71592392d075e57142edecaf"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a4b4b88ce71592392d075e57142edecaf">le_hashmap_ForEach</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, <a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a> forEachFn, void *contextPtr)</td></tr>
<tr class="separator:a4b4b88ce71592392d075e57142edecaf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8fb1d3a3d4c4b1b52a45205ac11a12c1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8fb1d3a3d4c4b1b52a45205ac11a12c1">le_hashmap_GetIterator</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a8fb1d3a3d4c4b1b52a45205ac11a12c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a601b7d3e5d92e91e4090d726e5b190ca"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:a601b7d3e5d92e91e4090d726e5b190ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad5cdb7a6d36d28699b255814c0d639d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aad5cdb7a6d36d28699b255814c0d639d">le_hashmap_PrevNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:aad5cdb7a6d36d28699b255814c0d639d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea0e64b3fee37053bba166c8a283f387"><td align="right" class="memItemLeft" valign="top">const void * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aea0e64b3fee37053bba166c8a283f387">le_hashmap_GetKey</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:aea0e64b3fee37053bba166c8a283f387"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf4761be6e9bf5a58155296e32c35c4b"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#adf4761be6e9bf5a58155296e32c35c4b">le_hashmap_GetValue</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:adf4761be6e9bf5a58155296e32c35c4b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeec5d4c2a49b8d0304efdfd469a1b2a4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aeec5d4c2a49b8d0304efdfd469a1b2a4">le_hashmap_GetFirstNode</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, void **firstKeyPtr, void **firstValuePtr)</td></tr>
<tr class="separator:aeec5d4c2a49b8d0304efdfd469a1b2a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a30f4e7da8135ef0274b24a86b7fcb7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a6a30f4e7da8135ef0274b24a86b7fcb7">le_hashmap_GetNodeAfter</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr, void **nextKeyPtr, void **nextValuePtr)</td></tr>
<tr class="separator:a6a30f4e7da8135ef0274b24a86b7fcb7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad31a0f34a74f765998467fa30096e46b"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ad31a0f34a74f765998467fa30096e46b">le_hashmap_CountCollisions</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:ad31a0f34a74f765998467fa30096e46b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3ff75de814b38d4c4283379acb406b65"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a3ff75de814b38d4c4283379acb406b65">le_hashmap_HashString</a> (const void *stringToHashPtr)</td></tr>
<tr class="separator:a3ff75de814b38d4c4283379acb406b65"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a63d2b6c0689ece50ce979557029b8483"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a63d2b6c0689ece50ce979557029b8483">le_hashmap_EqualsString</a> (const void *firstStringPtr, const void *secondStringPtr)</td></tr>
<tr class="separator:a63d2b6c0689ece50ce979557029b8483"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1bcf5d26bec7e15b6ec30fec4701ce03"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a1bcf5d26bec7e15b6ec30fec4701ce03">le_hashmap_HashUInt32</a> (const void *intToHashPtr)</td></tr>
<tr class="separator:a1bcf5d26bec7e15b6ec30fec4701ce03"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab3e3edfdbd30d06729486060a75a77c7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ab3e3edfdbd30d06729486060a75a77c7">le_hashmap_EqualsUInt32</a> (const void *firstIntPtr, const void *secondIntPtr)</td></tr>
<tr class="separator:ab3e3edfdbd30d06729486060a75a77c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a12558f1e0eeb68991ffb8f8ad442ce86"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a12558f1e0eeb68991ffb8f8ad442ce86">le_hashmap_HashUInt64</a> (const void *intToHashPtr)</td></tr>
<tr class="separator:a12558f1e0eeb68991ffb8f8ad442ce86"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b7ac9c681fc54fb121d94ee1e6f4c40"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a3b7ac9c681fc54fb121d94ee1e6f4c40">le_hashmap_EqualsUInt64</a> (const void *firstIntPtr, const void *secondIntPtr)</td></tr>
<tr class="separator:a3b7ac9c681fc54fb121d94ee1e6f4c40"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c9fc51c9f65c44f6c78cdaf101ab0e4"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a2c9fc51c9f65c44f6c78cdaf101ab0e4">le_hashmap_HashVoidPointer</a> (const void *voidToHashPtr)</td></tr>
<tr class="separator:a2c9fc51c9f65c44f6c78cdaf101ab0e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8ecdbbdb5cc0773f0f9946e6e4dec89c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8ecdbbdb5cc0773f0f9946e6e4dec89c">le_hashmap_EqualsVoidPointer</a> (const void *firstVoidPtr, const void *secondVoidPtr)</td></tr>
<tr class="separator:a8ecdbbdb5cc0773f0f9946e6e4dec89c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a853082500b05e57d899606cfc0e34fab"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a853082500b05e57d899606cfc0e34fab">le_hashmap_MakeTraceable</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a853082500b05e57d899606cfc0e34fab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a10b30e794df1c866fe39c40c7949eb29"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a10b30e794df1c866fe39c40c7949eb29">le_hashmap_EnableTrace</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a10b30e794df1c866fe39c40c7949eb29"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_hashmap.html">HashMap API</a> include file.</p>
<p class="copyright">Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a88f09b10323839a1a187b2fddab3ba0b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">#define LE_HASHMAP_MAKE_HASH</td>
<td>(</td>
<td class="paramtype"> </td>
<td class="paramname">type</td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<b>Value:</b><pre class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">size_t</span> Hash##type                                    \</div><div class="line">    (                                                           \</div><div class="line">        const <span class="keywordtype">void</span>* type##Name                                  \</div><div class="line">    )                                                           \</div><div class="line">    {                                                           \</div><div class="line">        size_t byte=0, hash = 0;                                \</div><div class="line">        unsigned <span class="keywordtype">char</span> c;                                        \</div><div class="line">        const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* ptr = type##Name;                  \</div><div class="line">        for (byte = 0; byte &lt; <span class="keyword">sizeof</span>(type); ++byte)             \</div><div class="line">        {                                                       \</div><div class="line">            c = *ptr++;                                         \</div><div class="line">            hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;       \</div><div class="line">        }                                                       \</div><div class="line">        return hash;                                            \</div><div class="line">    }                                                           \</div><div class="line">    static <span class="keywordtype">bool</span> Equals##type                                    \</div><div class="line">    (                                                           \</div><div class="line">        const <span class="keywordtype">void</span>* first##type,                                \</div><div class="line">        const <span class="keywordtype">void</span>* second##type                                \</div><div class="line">    )                                                           \</div><div class="line">    {                                                           \</div><div class="line">        return memcmp(first##type, second##type, <span class="keyword">sizeof</span>(type)) == 0; \</div><div class="line">    }</div></pre><!-- fragment --><p>Generic hash for any plain-old-datatype. </p>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adfe15673aeaa2400d3147d62abffee40"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef bool(* le_hashmap_EqualsFunc_t) (const void *firstKeyPtr, const void *secondKeyPtr)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Prototype for equality functions. The equality function returns true if the the keys point to values are equivalent. The HashMap doesn't know in advance which types are to be stored so this function must be supplied by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">firstKeyPtr</td><td>Pointer to the first key for comparing. </td></tr>
<tr><td class="paramname">secondKeyPtr</td><td>Pointer to the second key for comparing. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the values are the same, false otherwise </dd></dl>
</div>
</div>
<a class="anchor" id="acae181524ccab8958e1c8fd5855995b1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef bool(* le_hashmap_ForEachHandler_t) (const void *keyPtr, const void *valuePtr, void *contextPtr)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Prototype for callback functions for the iterator function <a class="el" href="le__hashmap_8h.html#a4b4b88ce71592392d075e57142edecaf">le_hashmap_ForEach()</a>. This function should return true in order to continue iterating, or false to stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">keyPtr</td><td>Pointer to the key at the current position in the map </td></tr>
<tr><td class="paramname">valuePtr</td><td>Pointer to the value associated to this key </td></tr>
<tr><td class="paramname">contextPtr</td><td>Pointer to the context supplied to <a class="el" href="le__hashmap_8h.html#a4b4b88ce71592392d075e57142edecaf">le_hashmap_ForEach()</a> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true to continue, false to stop </dd></dl>
</div>
</div>
<a class="anchor" id="a354b7f0a30dd40266d367351a4b248b7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef size_t(* le_hashmap_HashFunc_t) (const void *keyToHashPtr)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Prototype for hash functions. The hash function must generate a good spread of hashes without consuming lots of processing power.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">keyToHashPtr</td><td>Pointer to the key which will be hashed </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated hash value </dd></dl>
</div>
</div>
<a class="anchor" id="a8ab2021261a368add28c1be14f248459"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef struct le_hashmap_It* <a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>Reference to a HashMap Iterator. </p>
</div>
</div>
<a class="anchor" id="ae81c60860dbdb8c59beaf25985e5605a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef struct le_hashmap* <a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>Reference to a HashMap. </p>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af42bc33eaed4e6183edfbded3203beb4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_ContainsKey </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>keyPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Tests if the HashMap contains a particular key.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the key is found, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad31a0f34a74f765998467fa30096e46b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_hashmap_CountCollisions </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Counts the total number of collisions in the map. A collision occurs when more than one entry is stored in the map at the same index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total collisions in the map. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ade79896a5b2ceec82c570fe21f7efe3a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> le_hashmap_Create </td>
<td>(</td>
<td class="paramtype">const char * </td>
<td class="paramname"><em>nameStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>capacity</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a> </td>
<td class="paramname"><em>hashFunc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a> </td>
<td class="paramname"><em>equalsFunc</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a HashMap.</p>
<p>If you create a hashmap with a smaller capacity than you actually use, then the map will continue to work, but performance will degrade the more you put in the map.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Terminates the process on failure, so no need to check the return value for errors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">nameStr</td><td>Name of the HashMap </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Size of the hashmap </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">hashFunc</td><td>Hash function </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">equalsFunc</td><td>Equality function </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a10b30e794df1c866fe39c40c7949eb29"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_hashmap_EnableTrace </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Immediately enables tracing on a particular hashmap object. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a63d2b6c0689ece50ce979557029b8483"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_EqualsString </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>firstStringPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>secondStringPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>String equality function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a string</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the strings are identical, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">firstStringPtr</td><td>Pointer to the first string for comparing. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">secondStringPtr</td><td>Pointer to the second string for comparing. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab3e3edfdbd30d06729486060a75a77c7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_EqualsUInt32 </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>firstIntPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>secondIntPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Integer equality function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a uint32_t.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first integer for comparing. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second integer for comparing. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3b7ac9c681fc54fb121d94ee1e6f4c40"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_EqualsUInt64 </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>firstIntPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>secondIntPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Long integer equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint64_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first long integer for comparing. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second long integer for comparing. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8ecdbbdb5cc0773f0f9946e6e4dec89c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_EqualsVoidPointer </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>firstVoidPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>secondVoidPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pointer equality function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the pointers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">firstVoidPtr</td><td>First pointer for comparing. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">secondVoidPtr</td><td>Second pointer for comparing. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4b4b88ce71592392d075e57142edecaf"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_ForEach </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a> </td>
<td class="paramname"><em>forEachFn</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Iterates over the whole map, calling the supplied callback with each key-value pair. If the callback returns false for any key then this function will return.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if all elements were checked; or false if iteration was stopped early </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">forEachFn</td><td>Callback function to be called with each pair. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Pointer to a context to be supplied to the callback. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4322a312a2e4b00112022c2cb04eb416"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void* le_hashmap_Get </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>keyPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieve a value from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aeec5d4c2a49b8d0304efdfd469a1b2a4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_GetFirstNode </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void ** </td>
<td class="paramname"><em>firstKeyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void ** </td>
<td class="paramname"><em>firstValuePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves the key and value of the first node stored in the hashmap. The hashmap is not sorted so this will simply return the first node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the firstValuePointer then only the key will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the first node is returned or LE_NOT_FOUND if the map is empty. LE_BAD_PARAMETER if the key is NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">firstKeyPtr</td><td>Pointer to the first key </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">firstValuePtr</td><td>Pointer to the first value </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8fb1d3a3d4c4b1b52a45205ac11a12c1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> le_hashmap_GetIterator </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets an iterator for step-by-step iteration over the map. In this mode, the iteration is controlled by the calling function using the <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> function. There is one iterator per map, and calling this function resets the iterator position to the start of the map. The iterator is not ready for data access until <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has been called at least once.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns A reference to a hashmap iterator which is ready for <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> to be called on it </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aea0e64b3fee37053bba166c8a283f387"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">const void* le_hashmap_GetKey </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> </td>
<td class="paramname"><em>iteratorRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves a pointer to the key where the iterator is currently pointing. If the iterator has just been initialized and <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has not been called, or if the iterator has been invalidated, this will return NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current key, or NULL if the iterator has been invalidated or is not ready. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6a30f4e7da8135ef0274b24a86b7fcb7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_GetNodeAfter </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>keyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void ** </td>
<td class="paramname"><em>nextKeyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void ** </td>
<td class="paramname"><em>nextValuePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves the key and value of the node after the passed in key. The hashmap is not sorted so this will simply return the next node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the nextValuePtr then only the key will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the next node is returned. If the keyPtr is not found in the map then LE_BAD_PARAMETER is returned. LE_NOT_FOUND is returned if the passed in key is the last one in the map. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched for </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">nextKeyPtr</td><td>Pointer to the first key </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">nextValuePtr</td><td>Pointer to the first value </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9645e5b363c335e1dd324f536e2b754c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void* le_hashmap_GetStoredKey </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>keyPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieve a stored key from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the key that was stored in the HashMap by <a class="el" href="le__hashmap_8h.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put()</a> or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="adf4761be6e9bf5a58155296e32c35c4b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void* le_hashmap_GetValue </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> </td>
<td class="paramname"><em>iteratorRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieves a pointer to the value where the iterator is currently pointing. If the iterator has just been initialized and <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has not been called, or if the iterator has been invalidated, this will return NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current value, or NULL if the iterator has been invalidated or is not ready. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3ff75de814b38d4c4283379acb406b65"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_hashmap_HashString </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>stringToHashPtr</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>String hashing function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a string.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the string pointed to by stringToHash. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">stringToHashPtr</td><td>Pointer to the string to be hashed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1bcf5d26bec7e15b6ec30fec4701ce03"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_hashmap_HashUInt32 </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>intToHashPtr</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Integer hashing function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a uint32_t.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint32_t pointed to by intToHash. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the integer to be hashed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a12558f1e0eeb68991ffb8f8ad442ce86"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_hashmap_HashUInt64 </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>intToHashPtr</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Long integer hashing function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint64_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint64_t pointed to by intToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the long integer to be hashed </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2c9fc51c9f65c44f6c78cdaf101ab0e4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_hashmap_HashVoidPointer </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>voidToHashPtr</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pointer hashing function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference. Simply pass in the address as the key.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the pointer pointed to by voidToHashPtr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">voidToHashPtr</td><td>Pointer to be hashed </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5530fc9656f5e49f891541900bc21f34"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_hashmap_isEmpty </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Tests if the HashMap is empty (i.e. contains zero keys).</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if empty, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a853082500b05e57d899606cfc0e34fab"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_hashmap_MakeTraceable </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Makes a particular hashmap traceable without enabling the tracing. After this is called, when the trace keyword for this hashmap (the hashmap's name) is enabled for the "framework" component in the process, tracing will start. If that keyword was enabled before this function was called, tracing will start immediately when it is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a601b7d3e5d92e91e4090d726e5b190ca"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_NextNode </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> </td>
<td class="paramname"><em>iteratorRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Moves the iterator to the next key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the end of the map, then returns LE_NOT_FOUND. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aad5cdb7a6d36d28699b255814c0d639d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_PrevNode </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> </td>
<td class="paramname"><em>iteratorRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Moves the iterator to the previous key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the beginning of the map, then returns LE_NOT_FOUND. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a68759fb8291c487a507eae6d92710fc7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void* le_hashmap_Put </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>keyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>valuePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Add a key-value pair to a HashMap. If the key already exists in the map, the previous value will be replaced with the new value passed into this function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL for a new entry or a pointer to the old value if it is replaced. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be stored. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">valuePtr</td><td>Pointer to the value to be stored. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a64eab4c096da5b66aa54c70ec5d5a776"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void* le_hashmap_Remove </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>keyPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove a value from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be removed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a27e3af23871a2f9e8adffb748111aab2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_hashmap_RemoveAll </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Deletes all the entries held in the hashmap. This will not delete the data pointed to by the key and value pointers. That cleanup is the responsibility of the caller. This allows the map to be re-used. Currently maps can't be deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a481e3fa6b0fe8319074140a2cb2ae1cc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_hashmap_Size </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> </td>
<td class="paramname"><em>mapRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Calculates the number of keys in the HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keys in the HashMap. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
</div>
<br clear="left"/>
</div>
</div>
<link href="resources/css/jqtree.css" rel="stylesheet" type="text/css"/>
<script src="resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<link href="resources/css/perfect-scrollbar.min.css" rel="stylesheet"/>
<script src="resources/js/perfect-scrollbar.jquery.min.js"></script>
</body>
</html>
