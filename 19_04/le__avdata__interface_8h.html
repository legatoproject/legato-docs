<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html data-context="" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>le_avdata_interface.h File Reference - Legato Docs</title>
<meta content="legato™ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description"/>
<meta content="legato, iot" name="keywords"/>
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="19.04.0" name="legato-version"/>
<link href="resources/images/legato.ico" rel="shortcut icon"/>
<link href="resources/images/legato.ico" rel="icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="apple-touch-icon" type="image/x-icon"/>
<link href="resources/css/style.css" media="screen" rel="stylesheet" type="text/css"/>
<link href="resources/css/font-awesome.css" rel="stylesheet" type="text/css"/>
<!--[if IE]>
        <script src="resources/js/html5shiv.js"></script>
        <script src="resources/js/respond.js"></script>
        <![endif]-->
<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="resources/js/main.js"></script>
<script src=""></script>
</head>
<body>
<noscript>
<input class="modal-closing-trick" id="modal-closing-trick" type="checkbox"/>
<div id="nojs">
<label for="modal-closing-trick">
<span>You seem to not have Javascript <a href="http://enable-javascript.com">enabled</a>, so site functionality like the search and navigation tree won't work.</span>
</label>
</div>
</noscript>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/">Introduction</a><a class="navlink" href="buildAppsMain.html">Build Apps</a><a class="navlink" href="buildPlatformMain.html">Build Platform</a><a class="navlink" href="aboutMain.html">About</a>
</nav>
</header>
</div>
<div class="white" id="menudocumentation">
<header>
<a href="/"> <img alt="Back to Legato Homepage" id="logo" src="resources/images/legato_logo.png"/></a>
<h2>/ Legato Documentation</h2>
<nav class="secondary">
</nav>
<nav class="ui-front">
<i class="fa fa-search" id="search-icon"></i>
<input id="searchbox" placeholder="Search"/>
</nav>
</header>
</div>
<div id="resizable">
<div id="left">
<div id="tree1"></div>
</div>
</div>
<div class="content">
<div class="header">
<div class="summary">
<a href="#typedef-members">Typedefs</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<h1 class="title">le_avdata_interface.h File Reference</h1> </div>
</div><div class="contents">
<div class="textblock"><code>#include "legato.h"</code><br/>
<code>#include "le_avdata_common.h"</code><br/>
</div>
<p><a href="le__avdata__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adb6f618306231990bd39b283c547827d"><td align="right" class="memItemLeft" valign="top">typedef void(* </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#adb6f618306231990bd39b283c547827d">le_avdata_DisconnectHandler_t</a>) (void *)</td></tr>
<tr class="separator:adb6f618306231990bd39b283c547827d"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0f3c4d28bfe37aa29b6f519537b87da3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a0f3c4d28bfe37aa29b6f519537b87da3">le_avdata_ConnectService</a> (void)</td></tr>
<tr class="separator:a0f3c4d28bfe37aa29b6f519537b87da3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af9dc75ad35431dd76f2248bbd0da7f33"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#af9dc75ad35431dd76f2248bbd0da7f33">le_avdata_TryConnectService</a> (void)</td></tr>
<tr class="separator:af9dc75ad35431dd76f2248bbd0da7f33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb8de082e5015df3c13ed3069c90bba9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a410b5eb5dc002cff21fffc3d61d29532">LE_FULL_API</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#aeb8de082e5015df3c13ed3069c90bba9">le_avdata_SetServerDisconnectHandler</a> (<a class="el" href="le__avdata__interface_8h.html#adb6f618306231990bd39b283c547827d">le_avdata_DisconnectHandler_t</a> disconnectHandler, void *contextPtr)</td></tr>
<tr class="separator:aeb8de082e5015df3c13ed3069c90bba9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4210ebe082f4c821d10d5bed72f9c640"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a4210ebe082f4c821d10d5bed72f9c640">le_avdata_DisconnectService</a> (void)</td></tr>
<tr class="separator:a4210ebe082f4c821d10d5bed72f9c640"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adaf94585417ad8cf04efc890e1509f1f"><td align="right" class="memItemLeft" valign="top">le_avdata_ResourceEventHandlerRef_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#adaf94585417ad8cf04efc890e1509f1f">le_avdata_AddResourceEventHandler</a> (const char *LE_NONNULL path, le_avdata_ResourceHandlerFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr class="separator:adaf94585417ad8cf04efc890e1509f1f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6eeeffce135bdca4e95c516d1d1bc5bb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a6eeeffce135bdca4e95c516d1d1bc5bb">le_avdata_RemoveResourceEventHandler</a> (le_avdata_ResourceEventHandlerRef_t handlerRef)</td></tr>
<tr class="separator:a6eeeffce135bdca4e95c516d1d1bc5bb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9adb41270f7420fd269606c12f0a7c4c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a9adb41270f7420fd269606c12f0a7c4c">le_avdata_CreateResource</a> (const char *LE_NONNULL path, le_avdata_AccessMode_t accessMode)</td></tr>
<tr class="separator:a9adb41270f7420fd269606c12f0a7c4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47ebf50d61c4e1c4af08a8d7fbae45fa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a47ebf50d61c4e1c4af08a8d7fbae45fa">le_avdata_SetNamespace</a> (le_avdata_Namespace_t _namespace)</td></tr>
<tr class="separator:a47ebf50d61c4e1c4af08a8d7fbae45fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed0ca9d71814a5813b7761d10b73a39f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#aed0ca9d71814a5813b7761d10b73a39f">le_avdata_SetNull</a> (const char *LE_NONNULL path)</td></tr>
<tr class="separator:aed0ca9d71814a5813b7761d10b73a39f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a006ab36c1a32254dc1c3b2608f7d1c83"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a006ab36c1a32254dc1c3b2608f7d1c83">le_avdata_GetInt</a> (const char *LE_NONNULL path, int32_t *valuePtr)</td></tr>
<tr class="separator:a006ab36c1a32254dc1c3b2608f7d1c83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a61bafefd7356193f1d3111cceb8db1ad"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a61bafefd7356193f1d3111cceb8db1ad">le_avdata_SetInt</a> (const char *LE_NONNULL path, int32_t value)</td></tr>
<tr class="separator:a61bafefd7356193f1d3111cceb8db1ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e1b407f6bff2f1b6d6e76e014e71341"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a2e1b407f6bff2f1b6d6e76e014e71341">le_avdata_GetFloat</a> (const char *LE_NONNULL path, double *valuePtr)</td></tr>
<tr class="separator:a2e1b407f6bff2f1b6d6e76e014e71341"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b66143f2c24e403f9ede1679cd2af31"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a6b66143f2c24e403f9ede1679cd2af31">le_avdata_SetFloat</a> (const char *LE_NONNULL path, double value)</td></tr>
<tr class="separator:a6b66143f2c24e403f9ede1679cd2af31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a084dee5b151d80c1b41f34a4a10f8f5a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a084dee5b151d80c1b41f34a4a10f8f5a">le_avdata_GetBool</a> (const char *LE_NONNULL path, bool *valuePtr)</td></tr>
<tr class="separator:a084dee5b151d80c1b41f34a4a10f8f5a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aebdf8945bb2f58d816811ed177f14c70"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#aebdf8945bb2f58d816811ed177f14c70">le_avdata_SetBool</a> (const char *LE_NONNULL path, bool value)</td></tr>
<tr class="separator:aebdf8945bb2f58d816811ed177f14c70"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60804210f96415dea3fa6607f6f2937b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a60804210f96415dea3fa6607f6f2937b">le_avdata_GetString</a> (const char *LE_NONNULL path, char *value, size_t valueSize)</td></tr>
<tr class="separator:a60804210f96415dea3fa6607f6f2937b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0e512ce812aed3b52106d2b30a0ab54"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#ae0e512ce812aed3b52106d2b30a0ab54">le_avdata_SetString</a> (const char *LE_NONNULL path, const char *LE_NONNULL value)</td></tr>
<tr class="separator:ae0e512ce812aed3b52106d2b30a0ab54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac51d80f49bf4dcfca8a427fe0a18be59"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#ac51d80f49bf4dcfca8a427fe0a18be59">le_avdata_GetBoolArg</a> (le_avdata_ArgumentListRef_t argumentListRef, const char *LE_NONNULL argName, bool *boolArgPtr)</td></tr>
<tr class="separator:ac51d80f49bf4dcfca8a427fe0a18be59"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc5614a36388b455140c51536b1ea1c6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#adc5614a36388b455140c51536b1ea1c6">le_avdata_GetFloatArg</a> (le_avdata_ArgumentListRef_t argumentListRef, const char *LE_NONNULL argName, double *floatArgPtr)</td></tr>
<tr class="separator:adc5614a36388b455140c51536b1ea1c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8dfedb235f7abef826977279af11ccfb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a8dfedb235f7abef826977279af11ccfb">le_avdata_GetIntArg</a> (le_avdata_ArgumentListRef_t argumentListRef, const char *LE_NONNULL argName, int32_t *intArgPtr)</td></tr>
<tr class="separator:a8dfedb235f7abef826977279af11ccfb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a52415024f59ea875f281febdaafe61aa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a52415024f59ea875f281febdaafe61aa">le_avdata_GetStringArg</a> (le_avdata_ArgumentListRef_t argumentListRef, const char *LE_NONNULL argName, char *strArg, size_t strArgSize)</td></tr>
<tr class="separator:a52415024f59ea875f281febdaafe61aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a10871ede51f402b7df0463204fdc9fc6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a10871ede51f402b7df0463204fdc9fc6">le_avdata_GetStringArgLength</a> (le_avdata_ArgumentListRef_t argumentListRef, const char *LE_NONNULL argName, int32_t *strArgLenPtr)</td></tr>
<tr class="separator:a10871ede51f402b7df0463204fdc9fc6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aff2cc1ef8d7a1abdd14ebf37382ffc8c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#aff2cc1ef8d7a1abdd14ebf37382ffc8c">le_avdata_ReplyExecResult</a> (le_avdata_ArgumentListRef_t argumentListRef, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> result)</td></tr>
<tr class="separator:aff2cc1ef8d7a1abdd14ebf37382ffc8c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29358516371baeb8a3c3b03e5d2bd4ec"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a29358516371baeb8a3c3b03e5d2bd4ec">le_avdata_Push</a> (const char *LE_NONNULL path, le_avdata_CallbackResultFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr class="separator:a29358516371baeb8a3c3b03e5d2bd4ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac823201bbe5e33ae2e645fe3da10f2f6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#ac823201bbe5e33ae2e645fe3da10f2f6">le_avdata_PushStream</a> (const char *LE_NONNULL path, int fd, le_avdata_CallbackResultFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr class="separator:ac823201bbe5e33ae2e645fe3da10f2f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49d63022c31b5b80ee3538e490346324"><td align="right" class="memItemLeft" valign="top">le_avdata_RecordRef_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a49d63022c31b5b80ee3538e490346324">le_avdata_CreateRecord</a> (void)</td></tr>
<tr class="separator:a49d63022c31b5b80ee3538e490346324"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01949472601455ea064bdfe11cbe5dda"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a01949472601455ea064bdfe11cbe5dda">le_avdata_DeleteRecord</a> (le_avdata_RecordRef_t recordRef)</td></tr>
<tr class="separator:a01949472601455ea064bdfe11cbe5dda"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae64a45e6363082c978a1d17ed9637c76"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#ae64a45e6363082c978a1d17ed9637c76">le_avdata_RecordInt</a> (le_avdata_RecordRef_t recordRef, const char *LE_NONNULL path, int32_t value, uint64_t timestamp)</td></tr>
<tr class="separator:ae64a45e6363082c978a1d17ed9637c76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bfbffae6b12865d655f79d5e35c1363"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a6bfbffae6b12865d655f79d5e35c1363">le_avdata_RecordFloat</a> (le_avdata_RecordRef_t recordRef, const char *LE_NONNULL path, double value, uint64_t timestamp)</td></tr>
<tr class="separator:a6bfbffae6b12865d655f79d5e35c1363"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6410065e82c6c1845138b257a2ca866"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#af6410065e82c6c1845138b257a2ca866">le_avdata_RecordBool</a> (le_avdata_RecordRef_t recordRef, const char *LE_NONNULL path, bool value, uint64_t timestamp)</td></tr>
<tr class="separator:af6410065e82c6c1845138b257a2ca866"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a417247a6dbc83c0a8a5c2a2916c9e278"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a417247a6dbc83c0a8a5c2a2916c9e278">le_avdata_RecordString</a> (le_avdata_RecordRef_t recordRef, const char *LE_NONNULL path, const char *LE_NONNULL value, uint64_t timestamp)</td></tr>
<tr class="separator:a417247a6dbc83c0a8a5c2a2916c9e278"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0bca8b820b8175e11ad693582fc7f7b5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a0bca8b820b8175e11ad693582fc7f7b5">le_avdata_PushRecord</a> (le_avdata_RecordRef_t recordRef, le_avdata_CallbackResultFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr class="separator:a0bca8b820b8175e11ad693582fc7f7b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af36e54289bb16f2f29da4c7456560982"><td align="right" class="memItemLeft" valign="top">le_avdata_SessionStateHandlerRef_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#af36e54289bb16f2f29da4c7456560982">le_avdata_AddSessionStateHandler</a> (le_avdata_SessionStateHandlerFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr class="separator:af36e54289bb16f2f29da4c7456560982"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf24d6f2ced767cfa7cc07c2d051bd22"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#abf24d6f2ced767cfa7cc07c2d051bd22">le_avdata_RemoveSessionStateHandler</a> (le_avdata_SessionStateHandlerRef_t handlerRef)</td></tr>
<tr class="separator:abf24d6f2ced767cfa7cc07c2d051bd22"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1153ba43d55c59db3d36e3f44fd5ff10"><td align="right" class="memItemLeft" valign="top">le_avdata_RequestSessionObjRef_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a1153ba43d55c59db3d36e3f44fd5ff10">le_avdata_RequestSession</a> (void)</td></tr>
<tr class="separator:a1153ba43d55c59db3d36e3f44fd5ff10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1f0253c6388d80aa9c1ce7745a06cfe9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__avdata__interface_8h.html#a1f0253c6388d80aa9c1ce7745a06cfe9">le_avdata_ReleaseSession</a> (le_avdata_RequestSessionObjRef_t requestRef)</td></tr>
<tr class="separator:a1f0253c6388d80aa9c1ce7745a06cfe9"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_le_avdata.html">AirVantage Data API</a> include file.</p>
<p class="copyright">Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="adb6f618306231990bd39b283c547827d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6f618306231990bd39b283c547827d">◆ </a></span>le_avdata_DisconnectHandler_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef void(* le_avdata_DisconnectHandler_t) (void *)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Type for handler called when a server disconnects. </p>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adaf94585417ad8cf04efc890e1509f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf94585417ad8cf04efc890e1509f1f">◆ </a></span>le_avdata_AddResourceEventHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">le_avdata_ResourceEventHandlerRef_t le_avdata_AddResourceEventHandler </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_avdata_ResourceHandlerFunc_t </td>
<td class="paramname"><em>handlerPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Resource access modes:</p><ul>
<li>Variable: read (server), read/write (client)</li>
<li>Setting: read/write (server), read/write (client)</li>
<li>Command: execute (server) Resource access types Resource namespace Data types Status of the data push  Argument list reference, for command only. Handler for resource activity. Note that the path returned by this event follows the unix format (e.g. "/a/b/c") even if the app uses the URL format (e.g "a.b.c") when registering the handler. Handler for pushing data result. Reference type used by Add/Remove functions for EVENT 'le_avdata_ResourceEvent' A record reference Reference returned by RequestSession function and used by ReleaseSession function AVMS session state Handler for AV session changes Reference type used by Add/Remove functions for EVENT 'le_avdata_SessionState' Add handler function for EVENT 'le_avdata_ResourceEvent'</li>
</ul>
<p>Upon resource access on the server side, the registered handler is called.</p>
<p>For "settings" (read/write), the same handler is called for both read and write access.</p>
<p>For "commands", the handler function must call the "ReplyExecResult" function to send the command execution result back to the AVC daemon (which then sends the proper response back to the AV server). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af36e54289bb16f2f29da4c7456560982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36e54289bb16f2f29da4c7456560982">◆ </a></span>le_avdata_AddSessionStateHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">le_avdata_SessionStateHandlerRef_t le_avdata_AddSessionStateHandler </td>
<td>(</td>
<td class="paramtype">le_avdata_SessionStateHandlerFunc_t </td>
<td class="paramname"><em>handlerPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Add handler function for EVENT 'le_avdata_SessionState'</p>
<p>This event provides information on AV session state changes </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a0f3c4d28bfe37aa29b6f519537b87da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3c4d28bfe37aa29b6f519537b87da3">◆ </a></span>le_avdata_ConnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_ConnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Connect the current client thread to the service providing this API. Block until the service is available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically. </p>
</div>
</div>
<a id="a49d63022c31b5b80ee3538e490346324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d63022c31b5b80ee3538e490346324">◆ </a></span>le_avdata_CreateRecord()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">le_avdata_RecordRef_t le_avdata_CreateRecord </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a timeseries record</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the record </dd></dl>
</div>
</div>
<a id="a9adb41270f7420fd269606c12f0a7c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adb41270f7420fd269606c12f0a7c4c">◆ </a></span>le_avdata_CreateResource()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_CreateResource </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_avdata_AccessMode_t </td>
<td class="paramname"><em>accessMode</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create an asset data with the provided path. Note that asset data type and value are determined upon the first call to a Set function. When an asset data is created, it contains a null value, represented by the data type of none.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_DUPLICATE if path has already been called by CreateResource before, or path is parent or child to an existing Asset Data path.</li>
<li>LE_FAULT on any other error. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a01949472601455ea064bdfe11cbe5dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01949472601455ea064bdfe11cbe5dda">◆ </a></span>le_avdata_DeleteRecord()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_DeleteRecord </td>
<td>(</td>
<td class="paramtype">le_avdata_RecordRef_t </td>
<td class="paramname"><em>recordRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete a timeseries record </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">recordRef</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a4210ebe082f4c821d10d5bed72f9c640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4210ebe082f4c821d10d5bed72f9c640">◆ </a></span>le_avdata_DisconnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_DisconnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Disconnect the current client thread from the service providing this API.</p>
<p>Normally, this function doesn't need to be called. After this function is called, there's no longer a connection to the service, and the functions in this API can't be used. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically. </p>
</div>
</div>
<a id="a084dee5b151d80c1b41f34a4a10f8f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084dee5b151d80c1b41f34a4a10f8f5a">◆ </a></span>le_avdata_GetBool()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetBool </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool * </td>
<td class="paramname"><em>valuePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets the bool value of an asset data.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_BAD_PARAMETER - asset data being accessed is of the wrong data type</li>
<li>LE_UNAVAILABLE - asset data contains null value</li>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ac51d80f49bf4dcfca8a427fe0a18be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51d80f49bf4dcfca8a427fe0a18be59">◆ </a></span>le_avdata_GetBoolArg()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetBoolArg </td>
<td>(</td>
<td class="paramtype">le_avdata_ArgumentListRef_t </td>
<td class="paramname"><em>argumentListRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>argName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool * </td>
<td class="paramname"><em>boolArgPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the bool argument with the specified name.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NOT_FOUND if argument doesn't exist, or its data type doesn't match the API. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">argumentListRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">argName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">boolArgPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2e1b407f6bff2f1b6d6e76e014e71341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1b407f6bff2f1b6d6e76e014e71341">◆ </a></span>le_avdata_GetFloat()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetFloat </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>valuePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets the float value of an asset data.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_BAD_PARAMETER - asset data being accessed is of the wrong data type</li>
<li>LE_UNAVAILABLE - asset data contains null value</li>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="adc5614a36388b455140c51536b1ea1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5614a36388b455140c51536b1ea1c6">◆ </a></span>le_avdata_GetFloatArg()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetFloatArg </td>
<td>(</td>
<td class="paramtype">le_avdata_ArgumentListRef_t </td>
<td class="paramname"><em>argumentListRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>argName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>floatArgPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the float argument with the specified name.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NOT_FOUND if argument doesn't exist, or its data type doesn't match the API. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">argumentListRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">argName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">floatArgPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a006ab36c1a32254dc1c3b2608f7d1c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006ab36c1a32254dc1c3b2608f7d1c83">◆ </a></span>le_avdata_GetInt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetInt </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t * </td>
<td class="paramname"><em>valuePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets the integer value of an asset data.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_BAD_PARAMETER - asset data being accessed is of the wrong data type</li>
<li>LE_UNAVAILABLE - asset data contains null value</li>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a8dfedb235f7abef826977279af11ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfedb235f7abef826977279af11ccfb">◆ </a></span>le_avdata_GetIntArg()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetIntArg </td>
<td>(</td>
<td class="paramtype">le_avdata_ArgumentListRef_t </td>
<td class="paramname"><em>argumentListRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>argName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t * </td>
<td class="paramname"><em>intArgPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the int argument with the specified name.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NOT_FOUND if argument doesn't exist, or its data type doesn't match the API. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">argumentListRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">argName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">intArgPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a60804210f96415dea3fa6607f6f2937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60804210f96415dea3fa6607f6f2937b">◆ </a></span>le_avdata_GetString()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetString </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">char * </td>
<td class="paramname"><em>value</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>valueSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets the string value of an asset data.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_BAD_PARAMETER - asset data being accessed is of the wrong data type</li>
<li>LE_UNAVAILABLE - asset data contains null value</li>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OVERFLOW - asset data length exceeds the maximum length</li>
<li>LE_OK - access successful </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">value</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">valueSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a52415024f59ea875f281febdaafe61aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52415024f59ea875f281febdaafe61aa">◆ </a></span>le_avdata_GetStringArg()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetStringArg </td>
<td>(</td>
<td class="paramtype">le_avdata_ArgumentListRef_t </td>
<td class="paramname"><em>argumentListRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>argName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">char * </td>
<td class="paramname"><em>strArg</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>strArgSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the string argument with the specified name.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NOT_FOUND if argument doesn't exist, or its data type doesn't match the API</li>
<li>LE_OVERFLOW - argument length exceeds the maximum length </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">argumentListRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">argName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">strArg</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">strArgSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a10871ede51f402b7df0463204fdc9fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10871ede51f402b7df0463204fdc9fc6">◆ </a></span>le_avdata_GetStringArgLength()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_GetStringArgLength </td>
<td>(</td>
<td class="paramtype">le_avdata_ArgumentListRef_t </td>
<td class="paramname"><em>argumentListRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>argName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t * </td>
<td class="paramname"><em>strArgLenPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the length (excluding terminating null byte) of the string argument of the specified name.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NOT_FOUND if argument doesn't exist, or its data type doesn't match the API. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">argumentListRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">argName</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">strArgLenPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a29358516371baeb8a3c3b03e5d2bd4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29358516371baeb8a3c3b03e5d2bd4ec">◆ </a></span>le_avdata_Push()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_Push </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_avdata_CallbackResultFunc_t </td>
<td class="paramname"><em>handlerPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Push asset data to the server.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NOT_FOUND if the provided path doesn't exist</li>
<li>LE_BUSY if push service is busy. Data added to queue list for later push</li>
<li>LE_OVERFLOW if data size exceeds the maximum allowed size</li>
<li>LE_NO_MEMORY if push queue is full, try again later</li>
<li>LE_FAULT on any other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a0bca8b820b8175e11ad693582fc7f7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bca8b820b8175e11ad693582fc7f7b5">◆ </a></span>le_avdata_PushRecord()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_PushRecord </td>
<td>(</td>
<td class="paramtype">le_avdata_RecordRef_t </td>
<td class="paramname"><em>recordRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_avdata_CallbackResultFunc_t </td>
<td class="paramname"><em>handlerPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Push record to the server</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_BUSY if push service is busy. Data added to queue list for later push</li>
<li>LE_OVERFLOW if data size exceeds the maximum allowed size</li>
<li>LE_NO_MEMORY if push queue is full, try again later</li>
<li>LE_FAULT on any other error</li>
</ul>
</dd></dl>
<ul>
<li><dl class="section note"><dt>Note</dt><dd>If the caller is passing a bad pointer into this function, it is a fatal error, the function will not return. </dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">recordRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ac823201bbe5e33ae2e645fe3da10f2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac823201bbe5e33ae2e645fe3da10f2f6">◆ </a></span>le_avdata_PushStream()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_PushStream </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fd</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_avdata_CallbackResultFunc_t </td>
<td class="paramname"><em>handlerPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Push data dump to a specified path on the server.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_BUSY if push service is busy. Data added to queue list for later push</li>
<li>LE_OVERFLOW if data size exceeds the maximum allowed size</li>
<li>LE_NO_MEMORY if push queue is full, try again later</li>
<li>LE_FAULT on any other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af6410065e82c6c1845138b257a2ca866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6410065e82c6c1845138b257a2ca866">◆ </a></span>le_avdata_RecordBool()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_RecordBool </td>
<td>(</td>
<td class="paramtype">le_avdata_RecordRef_t </td>
<td class="paramname"><em>recordRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>value</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>timestamp</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Accumulate boolean data</p>
<dl class="section note"><dt>Note</dt><dd>The client will be terminated if the recordRef is not valid, or the resource doesn't exist</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NO_MEMORY if the current entry was NOT added because the time series buffer is full.</li>
<li>LE_FAULT on any other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">recordRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a6bfbffae6b12865d655f79d5e35c1363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfbffae6b12865d655f79d5e35c1363">◆ </a></span>le_avdata_RecordFloat()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_RecordFloat </td>
<td>(</td>
<td class="paramtype">le_avdata_RecordRef_t </td>
<td class="paramname"><em>recordRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>value</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>timestamp</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Accumulate float data</p>
<dl class="section note"><dt>Note</dt><dd>The client will be terminated if the recordRef is not valid, or the resource doesn't exist</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NO_MEMORY if the current entry was NOT added because the time series buffer is full.</li>
<li>LE_FAULT on any other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">recordRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ae64a45e6363082c978a1d17ed9637c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64a45e6363082c978a1d17ed9637c76">◆ </a></span>le_avdata_RecordInt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_RecordInt </td>
<td>(</td>
<td class="paramtype">le_avdata_RecordRef_t </td>
<td class="paramname"><em>recordRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t </td>
<td class="paramname"><em>value</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>timestamp</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Accumulate int data</p>
<dl class="section note"><dt>Note</dt><dd>The client will be terminated if the recordRef is not valid, or the resource doesn't exist</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NO_MEMORY if the current entry was NOT added because the time series buffer is full.</li>
<li>LE_FAULT on any other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">recordRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a417247a6dbc83c0a8a5c2a2916c9e278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417247a6dbc83c0a8a5c2a2916c9e278">◆ </a></span>le_avdata_RecordString()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_RecordString </td>
<td>(</td>
<td class="paramtype">le_avdata_RecordRef_t </td>
<td class="paramname"><em>recordRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>value</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>timestamp</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Accumulate string data</p>
<dl class="section note"><dt>Note</dt><dd>The client will be terminated if the recordRef is not valid, or the resource doesn't exist</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_NO_MEMORY if the current entry was NOT added because the time series buffer is full.</li>
<li>LE_FAULT on any other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">recordRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a1f0253c6388d80aa9c1ce7745a06cfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0253c6388d80aa9c1ce7745a06cfe9">◆ </a></span>le_avdata_ReleaseSession()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_ReleaseSession </td>
<td>(</td>
<td class="paramtype">le_avdata_RequestSessionObjRef_t </td>
<td class="paramname"><em>requestRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Request the avcServer to close a session. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">requestRef</td><td>Reference to a previously opened AV session. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a6eeeffce135bdca4e95c516d1d1bc5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeeffce135bdca4e95c516d1d1bc5bb">◆ </a></span>le_avdata_RemoveResourceEventHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_RemoveResourceEventHandler </td>
<td>(</td>
<td class="paramtype">le_avdata_ResourceEventHandlerRef_t </td>
<td class="paramname"><em>handlerRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove handler function for EVENT 'le_avdata_ResourceEvent' </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="abf24d6f2ced767cfa7cc07c2d051bd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf24d6f2ced767cfa7cc07c2d051bd22">◆ </a></span>le_avdata_RemoveSessionStateHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_RemoveSessionStateHandler </td>
<td>(</td>
<td class="paramtype">le_avdata_SessionStateHandlerRef_t </td>
<td class="paramname"><em>handlerRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove handler function for EVENT 'le_avdata_SessionState' </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aff2cc1ef8d7a1abdd14ebf37382ffc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2cc1ef8d7a1abdd14ebf37382ffc8c">◆ </a></span>le_avdata_ReplyExecResult()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_avdata_ReplyExecResult </td>
<td>(</td>
<td class="paramtype">le_avdata_ArgumentListRef_t </td>
<td class="paramname"><em>argumentListRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td>
<td class="paramname"><em>result</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Reply command execution result to AVC Daemon, which can then respond to AV server. This function MUST be called at the end of a command execution, in order for AV server to be notified about the execution status. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">argumentListRef</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">result</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a1153ba43d55c59db3d36e3f44fd5ff10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153ba43d55c59db3d36e3f44fd5ff10">◆ </a></span>le_avdata_RequestSession()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">le_avdata_RequestSessionObjRef_t le_avdata_RequestSession </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Request the avcServer to open a session.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SessionRef if session request succeeded</li>
<li>NULL if session request failed </li>
</ul>
</dd></dl>
</div>
</div>
<a id="aebdf8945bb2f58d816811ed177f14c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdf8945bb2f58d816811ed177f14c70">◆ </a></span>le_avdata_SetBool()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_SetBool </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>value</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets an asset data to a bool value.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a6b66143f2c24e403f9ede1679cd2af31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b66143f2c24e403f9ede1679cd2af31">◆ </a></span>le_avdata_SetFloat()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_SetFloat </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>value</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets an asset data to a float value.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a61bafefd7356193f1d3111cceb8db1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bafefd7356193f1d3111cceb8db1ad">◆ </a></span>le_avdata_SetInt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_SetInt </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t </td>
<td class="paramname"><em>value</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets an asset data to an integer value.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a47ebf50d61c4e1c4af08a8d7fbae45fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ebf50d61c4e1c4af08a8d7fbae45fa">◆ </a></span>le_avdata_SetNamespace()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_SetNamespace </td>
<td>(</td>
<td class="paramtype">le_avdata_Namespace_t </td>
<td class="paramname"><em>_namespace</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets the namespace for asset data.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_OK on success</li>
<li>LE_BAD_PARAMETER if the namespace is unknown </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">_namespace</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aed0ca9d71814a5813b7761d10b73a39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0ca9d71814a5813b7761d10b73a39f">◆ </a></span>le_avdata_SetNull()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_SetNull </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets an asset data to contain a null value, represented by the data type of none.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aeb8de082e5015df3c13ed3069c90bba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8de082e5015df3c13ed3069c90bba9">◆ </a></span>le_avdata_SetServerDisconnectHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a410b5eb5dc002cff21fffc3d61d29532">LE_FULL_API</a> void le_avdata_SetServerDisconnectHandler </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__avdata__interface_8h.html#adb6f618306231990bd39b283c547827d">le_avdata_DisconnectHandler_t</a> </td>
<td class="paramname"><em>disconnectHandler</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set handler called when server disconnection is detected.</p>
<p>When a server connection is lost, call this handler then exit with LE_FATAL. If a program wants to continue without exiting, it should call longjmp() from inside the handler. </p>
</div>
</div>
<a id="ae0e512ce812aed3b52106d2b30a0ab54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e512ce812aed3b52106d2b30a0ab54">◆ </a></span>le_avdata_SetString()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_SetString </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>path</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>value</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets an asset data to a string value.</p>
<dl class="section return"><dt>Returns</dt><dd>:<ul>
<li>LE_NOT_FOUND - if the path is invalid and does not point to an asset data</li>
<li>LE_NOT_PERMITTED - asset data being accessed does not have the right permission</li>
<li>LE_OK - access successful. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">path</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af9dc75ad35431dd76f2248bbd0da7f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9dc75ad35431dd76f2248bbd0da7f33">◆ </a></span>le_avdata_TryConnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_avdata_TryConnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Try to connect the current client thread to the service providing this API. Return with an error if the service is not available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if the client connected successfully to the service.</li>
<li>LE_UNAVAILABLE if the server is not currently offering the service to which the client is bound.</li>
<li>LE_NOT_PERMITTED if the client interface is not bound to any service (doesn't have a binding).</li>
<li>LE_COMM_ERROR if the Service Directory cannot be reached. </li>
</ul>
</dd></dl>
</div>
</div>
</div>
<br clear="left"/>
</div>
</div>
<link href="resources/css/jqtree.css" rel="stylesheet" type="text/css"/>
<script src="resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<link href="resources/css/perfect-scrollbar.min.css" rel="stylesheet"/>
<script src="resources/js/perfect-scrollbar.jquery.min.js"></script>
</body>
</html>
