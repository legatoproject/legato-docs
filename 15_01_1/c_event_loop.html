<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: Event Loop API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('c_event_loop.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Event Loop API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="le__event_loop_8h.html">API Reference</a></p>
<hr/>
<p>The Event Loop API supports Legato's <a class="el" href="basic_components.html#programmingModel">Component Programming Model</a>. In this event-driven programming model, a central <b> event loop </b> calls <b> event handler </b> functions in response to <b>event reports</b>.</p>
<p>Software components register their event handler functions with the event system (either directly through the Event Loop API or indirectly through other APIs that use the Event Loop API) so the central event loop knows the functions to call in response to defined events.</p>
<p>Every event loop has an <b>event queue</b>, which is a queue of events waiting to be handled by that event loop. The following different usage patterns are supported by the Event Loop API:</p>
<dl class="section note"><dt>Note</dt><dd>When the process dies, all events, event loops, queues, reports, and handlers will be automatically cleared.</dd></dl>
<h1><a class="anchor" id="c_event_deferredFunctionCalls"></a>
Deferred Function Calls</h1>
<p>A basic Event Queue usage is to queue a function for the Event Loop to call later (when that function gets to the head of the Event Queue) by calling l<code>e_event_QueueFunction()</code>.</p>
<p>This code sample has a component initialization function queueing another function to be call later, by the process's main thread when the Event Loop is running. Two parameters are needed by the deferred function. The third is just filled with NULL and ignored by the deferred function.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyDeferredFunction</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* param1Ptr,</div>
<div class="line">    <span class="keywordtype">void</span>* param2Ptr</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Type cast the parameters to what they really are and do whatever it is that</span></div>
<div class="line">    <span class="comment">// I need to do with them.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">COMPONENT_INIT</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#a6dcc88f96060c5bc107a81a978132f38">le_event_QueueFunction</a>(MyDeferredFunction, firstParamPtr, secondParamPtr);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Deferred function calls are useful when implementing APIs with asynchronous result call-backs. If an error is detected before the API function returns, it can't just call the call-back directly, because it could cause re-entrancy problems in the client code or cause recursive loops. Instead of forcing the API function to return an error code in special cases (which will increase the client's code complexity and may leak API implementation details to the client), the API function can defers executing the call-back until later by queuing an error handling function onto the Event Queue.</p>
<h1><a class="anchor" id="c_event_publishSubscribe"></a>
Publish-Subscribe Events</h1>
<p>In the publish-subscribe pattern, someone publishes information and if anyone cares about that information, they subscribe to receive it. The publisher doesn't have to know whether anything is listening, or how many subscribers might be listening. Likewise, the subscribers don't have to know whether anything is publishing or how many publishers there might be. This decouples publishers and subscribers.</p>
<p>Subscribers <b>add</b> handlers for events and wait for those handlers to be executed.</p>
<p>Publishers <b>report</b> events.</p>
<p>When an event report reaches the front of an Event Queue, the Event Loop will pop it from the queue and call any handlers that have been registered for that event.</p>
<p>Events are identified using an <b> Event ID </b> created by calling <code><a class="el" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId()</a></code> before registering an handler for that event or report. Any thread within the process with an Event ID can register a handler or report events.</p>
<dl class="section note"><dt>Note</dt><dd>These Event IDs are only valid within the process where they were created. The Event Loop API can't be used for inter-process communication (IPC).</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> eventId = <a class="code" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a>(<span class="stringliteral">&quot;MyEvent&quot;</span>, <span class="keyword">sizeof</span>(MyEventReport_t));</div>
</div><!-- fragment --><p>Event reports can carry a payload. The size and format of the payload depends on the type of event. For example, reports of temperature changes may need to carry the new temperature. To support this, <code><a class="el" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId()</a></code> takes the payload size as a parameter.</p>
<p>To report an event, the publisher builds their report payload in their own buffer and passes a pointer to that buffer (and its size) to <code><a class="el" href="le__event_loop_8h.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report()</a></code>:</p>
<div class="fragment"><div class="line">MyEventReport_t report;</div>
<div class="line">...     <span class="comment">// Fill in the event report.</span></div>
<div class="line"><a class="code" href="le__event_loop_8h.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report</a>(EventId, &amp;report, <span class="keyword">sizeof</span>(report));</div>
</div><!-- fragment --><p>This results in the report getting queued to the Event Queues of all threads with handlers registered for that event ID.</p>
<p>To register a handler, the subscriber calls <code><a class="el" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>It's okay to have a payload size of zero, in which case NULL can be passed into <a class="el" href="le__event_loop_8h.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report()</a>.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> handlerRef = <a class="code" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a>(<span class="stringliteral">&quot;MyHandler&quot;</span>, eventId, MyHandlerFunc);</div>
</div><!-- fragment --><p>When an event report reaches the front of a thread's Event Queue, that thread's Event Loop reads the report and then:</p>
<ul>
<li>Calls the handler functions registered by that thread.</li>
<li>Points to the report payload passed to the handler as a parameter.</li>
<li>Reports the payload was deleted on return, so the handler function must copy any contents to keep.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyHandlerFunc</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* reportPayloadPtr</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    MyEventReport_t* reportPtr = reportPayloadPtr;</div>
<div class="line">    <span class="comment">// Process the report.</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another opaque pointer, called the <b> context pointer </b> can be set for the handler using <code><a class="el" href="le__event_loop_8h.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr()</a></code>. When the handler function is called, it can call <a class="el" href="le__event_loop_8h.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr()</a> to fetch the context pointer.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyHandlerFunc</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* reportPayloadPtr</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    MyEventReport_t* reportPtr = reportPayloadPtr;</div>
<div class="line">    MyContext_t* contextPtr = <a class="code" href="le__event_loop_8h.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Process the report.</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div>
<div class="line">{</div>
<div class="line">    MyEventId = <a class="code" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a>(<span class="stringliteral">&quot;MyEvent&quot;</span>, <span class="keyword">sizeof</span>(MyEventReport_t));</div>
<div class="line"></div>
<div class="line">    MyHandlerRef = <a class="code" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a>(<span class="stringliteral">&quot;MyHandler&quot;</span>, MyEventId, MyHandlerFunc);</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr</a>(MyHandlerRef, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, <a class="el" href="le__event_loop_8h.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler()</a> can be used to remove an event handler registration, if necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler</a>(MyHandlerRef);</div>
</div><!-- fragment --><p>If a handler is removed after the report for that event has been added to the event queue, but before the report reaches the head of the queue, then the handler will not be called.</p>
<dl class="section note"><dt>Note</dt><dd>To prevent race conditions, it's not permitted for one thread to remove another thread's handlers.</dd></dl>
<h1><a class="anchor" id="c_event_layeredPublishSubscribe"></a>
Layered Publish-Subscribe Handlers</h1>
<p>If you need to implement an API that allows clients to register "handler" functions to be called-back after a specific event occurs, the Event Loop API provides some special help.</p>
<p>You can have the Event Loop call your handler function (the first-layer handler), to unpack specified items from the Event Report and call the client's handler function (the second-layer handler).</p>
<p>For example, you could create a "Temperature Sensor API" that allows its clients to register handler functions to be called to handle changes in the temperature, like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Temperature change handler functions must look like this.</span></div>
<div class="line"><span class="keyword">typedef</span> void (*tempSensor_ChangeHandlerFunc_t)(int32_t newTemperature, <span class="keywordtype">void</span>* contextPtr);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Opaque type used to refer to a registered temperature change handler.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>tempSensor_ChangeHandler* tempSensor_ChangeHandlerRef_t;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Register a handler function to be called when the temperature changes.</span></div>
<div class="line">tempSensor_ChangeHandlerRef_t tempSensor_AddChangeHandler</div>
<div class="line">(</div>
<div class="line">    tempSensor_ChangeHandlerFunc_t  handlerFunc,  <span class="comment">// The handler function.</span></div>
<div class="line">    <span class="keywordtype">void</span>*                           contextPtr    <span class="comment">// Opaque pointer to pass to handler function.</span></div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// De-register a handler function that was previously registered using</span></div>
<div class="line"><span class="comment">// tempSensor_AddChangeHandler().</span></div>
<div class="line"><span class="keywordtype">void</span> tempSensor_RemoveChangeHandler</div>
<div class="line">(</div>
<div class="line">    tempSensor_ChangeHandlerRef_t  handlerRef</div>
<div class="line">);</div>
</div><!-- fragment --><p>The implementation could look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div>
<div class="line">{</div>
<div class="line">    TempChangeEventId = <a class="code" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a>(<span class="stringliteral">&quot;TempChange&quot;</span>, <span class="keyword">sizeof</span>(int32_t));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> TempChangeHandler</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* reportPtr,</div>
<div class="line">    <span class="keywordtype">void</span>* secondLayerHandlerFunc</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    int32_t* temperaturePtr = reportPtr;</div>
<div class="line">    tempSensor_ChangeHandlerRef_t clientHandlerFunc = secondLayerHandlerFunc;</div>
<div class="line"></div>
<div class="line">    clientHandlerFunc(*temperaturePtr, <a class="code" href="le__event_loop_8h.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">tempSensor_ChangeHandlerRef_t tempSensor_AddChangeHandler</div>
<div class="line">(</div>
<div class="line">    tempSensor_ChangeHandlerFunc_t  handlerFunc,</div>
<div class="line">    <span class="keywordtype">void</span>*                           contextPtr</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> handlerRef;</div>
<div class="line"></div>
<div class="line">    handlerRef = <a class="code" href="le__event_loop_8h.html#a8b906d38935f64953482f42c745e1c18">le_event_AddLayeredHandler</a>(<span class="stringliteral">&quot;TempChange&quot;</span>,</div>
<div class="line">                                            TempChangeEventId,</div>
<div class="line">                                            TempChangeHandler,</div>
<div class="line">                                            handlerFunc);</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr</a>(handlerRef, contextPtr);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> (tempSensor_ChangeHandlerRef_t)handlerRef;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> tempSensor_RemoveChangeHandler</div>
<div class="line">(</div>
<div class="line">    tempSensor_ChangeHandlerRef_t    handlerRef</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler</a>((<a class="code" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a>)handlerRef);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This approach gives strong type checking of both handler references and handler function pointers in code that uses this Temperature Sensor API.</p>
<h1><a class="anchor" id="c_event_files"></a>
Working with File Descriptors</h1>
<p>In a POSIX environment, like Linux, file descriptors are used for most process I/O. Many components will need to be notified when one or more file descriptors are ready to read from or write to, or experience an error or hang-up.</p>
<p>In conventional programs, it's common to block a thread on a call to <code>read()</code>, <code>write()</code>, <code>accept()</code>, <code>select()</code>, <code>poll()</code>, or some variant of those functions. But if that's done in a thread shared with other components, those other components would be unable to run when needed. To avoid this, the Legato event system provides methods to monitor file descriptors and report related events so they won't interfere with other software sharing the same thread.</p>
<p>To start monitoring a file descriptor:</p>
<ol type="1">
<li>a <b> File Descriptor Monitor </b> object is created for that file descriptor (by calling <a class="el" href="le__event_loop_8h.html#a02259f592867e8282bea379d4822a3d0">le_event_CreateFdMonitor()</a> ) and</li>
<li>event handler functions are registered with it (by calling <a class="el" href="le__event_loop_8h.html#ae31e605db307b38ffd4acbf4fe3440a6">le_event_SetFdHandler()</a>).</li>
<li>optionally, make the event deferrable until next system resume (by calling <a class="el" href="le__event_loop_8h.html#a30dd9daadc577761a994d8dd3df1e664">le_event_WakeUp()</a> with wakeUp flag set to 'false').</li>
</ol>
<p>File descriptor event handler functions receive a file descriptor as their only parameter, instead of receiving a report pointer. See <a class="el" href="le__event_loop_8h.html#a606fac65f1b43673716f4c354d809045">le_event_FdEventType_t</a> for a list of events that can be handled for file descriptors.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Open the serial port.</span></div>
<div class="line">    <span class="keywordtype">int</span> fd = open(<span class="stringliteral">&quot;/dev/ttyS0&quot;</span>, O_RDWR|O_NONBLOCK);</div>
<div class="line">    <a class="code" href="le__log_8h.html#a7a3e66a87026cc9e57bcb748840ab41b">LE_FATAL_IF</a>(fd == -1, <span class="stringliteral">&quot;open failed with errno %d (%m)&quot;</span>, errno);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a File Descriptor Monitor object for the serial port&#39;s file descriptor.</span></div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#a201323e1e87c6e90579559c57d352121">le_event_FdMonitorRef_t</a> fdMonitor = <a class="code" href="le__event_loop_8h.html#a02259f592867e8282bea379d4822a3d0">le_event_CreateFdMonitor</a>(<span class="stringliteral">&quot;PortMonitor&quot;</span>, fd);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Register a read handler (note: context pointer is unused in this example).</span></div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae31e605db307b38ffd4acbf4fe3440a6">le_event_SetFdHandler</a>(fdMonitor, <a class="code" href="le__event_loop_8h.html#a606fac65f1b43673716f4c354d809045ab9acca3317832bd35c4a5938e0d5c408">LE_EVENT_FD_READABLE</a>, MyReadHandler);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyReadHandler(<span class="keywordtype">int</span> fd)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> buff[MY_BUFF_SIZE];</div>
<div class="line"></div>
<div class="line">    ssize_t bytesRead = read(fd, buff, <span class="keyword">sizeof</span>(buff));</div>
<div class="line"></div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>If an event occurs on a file descriptor where there is no handler for that event on that file descriptor, the event will be ignored. If a handler is later registered for that event, and that event's trigger condition is still true (e.g., the file descriptor still has data available to be read), then the event will be reported to the handler at that time. If the event trigger condition is gone (e.g., the file descriptor no longer has data available to read), then the event will not be reported until its trigger condition becomes true again.</p>
<p>If events occur on different file descriptors at the same time, the order in which the handlers are called is implementation-dependent. If multiple events occur on the same file descriptor at the same time, handlers will be called in the same order as the events appear in the <a class="el" href="le__event_loop_8h.html#a606fac65f1b43673716f4c354d809045">le_event_FdEventType_t</a> enumeration (first event's handler will be called first). For example, if data arrives and the far end closes the connection, the "readable" event handler would be called before the "read hang up" event handler.</p>
<p>When a file descriptor no longer needs to be monitored, the File Descriptor Monitor object is deleted by calling <a class="el" href="le__event_loop_8h.html#a6ff974923aed7be0e3a39477e24d9df5">le_event_DeleteFdMonitor()</a>. There's no need to remove its handlers first.</p>
<dl class="section warning"><dt>Warning</dt><dd>Depending on the implementation, strange behaviour may occur if a file descriptor is closed while being monitored and then the same file descriptor is reused for something else before its Monitor object is deleted. Always delete the Monitor object for a file descriptor when it is closed.</dd></dl>
<p>A file descriptor event handler can be removed (deregistered) using <code><a class="el" href="le__event_loop_8h.html#a6a44474e915f91f20c8bd950d50d8e92">le_event_ClearFdHandler()</a></code> or <a class="el" href="le__event_loop_8h.html#a239bcc93a0cd8b5d34a89d0a5216ac84">le_event_ClearFdHandlerByEventType()</a>. This is useful monitor writeability. When the file descriptor is writeable, but there's nothing to write, the writeability handler will be continuously run until it's cleared or enough data is written into the file descriptor to cause it to become unwriteable. Allowing the handler to continually run is a colossal waste of CPU cycles and power. To prevent this, clear the writeability handler and set it again later when an attempt to write is rejected because the file descriptor is no longer writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> DoWrite()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> result = WriteMoreStuff();</div>
<div class="line">    <span class="keywordflow">if</span> (result == <a class="code" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86ca5016e2f65890028d6642e010891a113f">LE_WOULD_BLOCK</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The connection is not writeable (because its send buffers are full).</span></div>
<div class="line">        <span class="comment">// Register for notification when it becomes writeable again.</span></div>
<div class="line">        FdWriteableHandlerRef = <a class="code" href="le__event_loop_8h.html#ae31e605db307b38ffd4acbf4fe3440a6">le_event_SetFdHandler</a>(FdMonitorRef,</div>
<div class="line">                                                      <a class="code" href="le__event_loop_8h.html#a606fac65f1b43673716f4c354d809045a0b90f2c336a41f2c84830ff0c9c36378">LE_EVENT_FD_WRITEABLE</a>,</div>
<div class="line">                                                      ContinueWriting);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ContinueWriting(<span class="keywordtype">int</span> fd)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#a6a44474e915f91f20c8bd950d50d8e92">le_event_ClearFdHandler</a>(FdWriteableHandlerRef);</div>
<div class="line"></div>
<div class="line">    DoWrite();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="c_event_dispatchingToOtherThreads"></a>
Dispatching Function Execution to Other Threads</h1>
<p>In multi-threaded programs, sometimes the implementor needs to ask another thread to run a function because:</p>
<ul>
<li>The function to be executed takes a long time, but doesn't have to be done at a high priority.</li>
<li>A call needs to be made into a non-thread-safe API function.</li>
<li>A blocking function needs to be called, but the current thread can't afford to block.</li>
</ul>
<p>To assist with this, the Event Loop API provides <code><a class="el" href="le__event_loop_8h.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread()</a></code>. It works the same as <a class="el" href="le__event_loop_8h.html#a6dcc88f96060c5bc107a81a978132f38">le_event_QueueFunction()</a>, except that it queues the function onto a specific thread's Event Queue.</p>
<p>If the other thread isn't running the Event Loop, then the queued function will never be executed.</p>
<p>This code sample shows two arguments started by the process's main thread, and executed in the background by a low-priority thread. The result is reported back to the client through a completion callback running in the same thread that requested that the computation be performed.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> le_mem_PoolRef_t ComputeRequestPool;</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> LowPriorityThreadRef;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span>           arg1;                                   <span class="comment">// First argument</span></div>
<div class="line">    <span class="keywordtype">size_t</span>           arg2;                                   <span class="comment">// Second argument</span></div>
<div class="line">    ssize_t          result;                                 <span class="comment">// The result</span></div>
<div class="line">    void           (*completionCallback)(ssize_t result);    <span class="comment">// The client&#39;s completion callback</span></div>
<div class="line">    <a class="code" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>  requestingThreadRef;                    <span class="comment">// The client&#39;s thread.</span></div>
<div class="line">}</div>
<div class="line">ComputeRequest_t;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Main function of low-priority background thread.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>* LowPriorityThreadMain</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* contextPtr <span class="comment">// not used.</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div>
<div class="line">{</div>
<div class="line">    ComputeRequestPool = <a class="code" href="le__mem_8h.html#afc7288e04f1afff41a83a4da974726ab">le_mem_CreatePool</a>(<span class="stringliteral">&quot;Compute Request&quot;</span>, <span class="keyword">sizeof</span>(ComputeRequest_t));</div>
<div class="line"></div>
<div class="line">    LowPriorityThreadRef = <a class="code" href="le__thread_8h.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create</a>(<span class="stringliteral">&quot;Background Computation Thread&quot;</span>,</div>
<div class="line">                                            LowPriorityThreadMain,</div>
<div class="line">                                            NULL);</div>
<div class="line">    <a class="code" href="le__thread_8h.html#a95257a2f60cacdadc787647453b77356">le_thread_SetPriority</a>(LowPriorityThreadRef, <a class="code" href="le__thread_8h.html#a653b0f17cd4d4567c86a25e23d004f07a8237422b4c3d3df0ffcdbc9981c45d98">LE_THREAD_PRIORITY_IDLE</a>);</div>
<div class="line">    <a class="code" href="le__thread_8h.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start</a>(LowPriorityThreadRef);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This function gets run by a low-priority, background thread.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ComputeResult</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* param1Ptr, <span class="comment">// request object pointer</span></div>
<div class="line">    <span class="keywordtype">void</span>* param2Ptr  <span class="comment">// not used</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    ComputeRequest_t* requestPtr = param1Ptr;</div>
<div class="line"></div>
<div class="line">    requestPtr-&gt;result = DoSomeReallySlowComputation(requestPtr-&gt;arg1, requestPtr-&gt;arg2);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread</a>(requestPtr-&gt;requestingThreadRef,</div>
<div class="line">                                   ProcessResult,</div>
<div class="line">                                   requestPtr,</div>
<div class="line">                                   NULL);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This function gets called by a component running in the main thread.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ComputeResultInBackground</div>
<div class="line">(</div>
<div class="line">     <span class="keywordtype">size_t</span> arg1,</div>
<div class="line">     <span class="keywordtype">size_t</span> arg2,</div>
<div class="line">     <span class="keywordtype">void</span> (*completionCallback)(ssize_t result)</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    ComputeRequest_t* requestPtr = <a class="code" href="le__mem_8h.html#af7c289c73d4182835a26a9099f3db359">le_mem_ForceAlloc</a>(ComputeRequestPool);</div>
<div class="line">    requestPtr-&gt;arg1 = arg1;</div>
<div class="line">    requestPtr-&gt;arg2 = arg2;</div>
<div class="line">    requestPtr-&gt;requestingThreadRef = <a class="code" href="le__thread_8h.html#a90a9d67db26f816fd1e1032d74a24fcd">le_thread_GetCurrent</a>();</div>
<div class="line">    requestPtr-&gt;completionCallback = completionCallback;</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread</a>(LowPriorityThreadRef,</div>
<div class="line">                                   ComputeResult,</div>
<div class="line">                                   requestPtr,</div>
<div class="line">                                   NULL);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This function gets run by the main thread.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ProcessResult</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* param1Ptr, <span class="comment">// request object pointer</span></div>
<div class="line">    <span class="keywordtype">void</span>* param2Ptr  <span class="comment">// not used</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    ComputeRequest_t* requestPtr = param1Ptr;</div>
<div class="line">    completionCallback(requestPtr-&gt;result);</div>
<div class="line">    <a class="code" href="le__mem_8h.html#a6d8e3fe430bcb81efe97b57ce30ef2de">le_mem_Release</a>(requestPtr);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="c_event_reportingRefCountedObjects"></a>
Event Reports Containing Reference-Counted Objects</h1>
<p>Sometimes you need to report an event where the report payload is pointing to a reference-counted object allocated from a memory pool (see <a class="el" href="c_memory.html">Dynamic Memory Allocation API</a>). Memory leaks and/or crashes can result if its is sent through the Event Loop API without telling the Event Loop API it's pointing to a reference counted object. If there are no subscribers, the Event Loop API iscards the reference without releasing it, and the object is never be deleted. If multiple handlers are registered, the reference could be released by the handlers too many times. Also, there are other, subtle issues that are nearly impossible to solve if threads terminate while reports containing pointers to reference-counted objects are on their Event Queues.</p>
<p>To help with this, the functions <code><a class="el" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting()</a></code> and <code><a class="el" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a></code> have been provided. These allow a pointer to a reference-counted memory pool object to be sent as the payload of an Event Report.</p>
<p><code><a class="el" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a></code> passes ownership of one reference to the Event Loop API, and when the handler is called, it receives ownership for one reference. It then becomes the handler's responsibility to release its reference (using <a class="el" href="le__mem_8h.html#a6d8e3fe430bcb81efe97b57ce30ef2de">le_mem_Release()</a>) when it's done.</p>
<p><code><a class="el" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting()</a></code> is used the same way as <a class="el" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId()</a>, except that it doesn't require a payload size as the payload is always known from the pointer to a reference-counted memory pool object. Only Event IDs created using <a class="el" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting()</a> can be used with <a class="el" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> EventId;</div>
<div class="line">le_mem_PoolRef_t MyObjectPoolRef;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyHandler</div>
<div class="line">(</div>
<div class="line">    <span class="keywordtype">void</span>* reportPtr  <span class="comment">// Pointer to my reference-counted object.</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    MyObj_t* objPtr = reportPtr;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do something with the object.</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Okay, I&#39;m done with the object now.</span></div>
<div class="line">    <a class="code" href="le__mem_8h.html#a6d8e3fe430bcb81efe97b57ce30ef2de">le_mem_Release</a>(objPtr);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div>
<div class="line">{</div>
<div class="line">    EventId = <a class="code" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting</a>(<span class="stringliteral">&quot;SomethingHappened&quot;</span>);</div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a>(<span class="stringliteral">&quot;SomethingHandler&quot;</span>, EventId, MyHandler);</div>
<div class="line">    MyObjectPoolRef = <a class="code" href="le__mem_8h.html#afc7288e04f1afff41a83a4da974726ab">le_mem_CreatePool</a>(<span class="stringliteral">&quot;MyObjects&quot;</span>, <span class="keyword">sizeof</span>(MyObj_t));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ReportSomethingDetected</div>
<div class="line">(</div>
<div class="line">    ...</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    MyObj_t* objPtr = <a class="code" href="le__mem_8h.html#af7c289c73d4182835a26a9099f3db359">le_mem_ForceAlloc</a>(MyObjectPool);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fill in the object.</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <a class="code" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting</a>(EventId, objPtr);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="c_event_miscThreadingTopics"></a>
Miscellaneous Multithreading Topics</h1>
<p>All functions in this API are thread safe.</p>
<p>Each thread can have only one Event Loop. The main thread in every Legato process will always run an Event Loop after it's run the component initialization functions. As soon as all component initialization functions have returned, the main thread will start processing its event queue.</p>
<p>When a function is called to "Add" an event handler, that handler is associated with the calling thread's Event Loop. If the calling thread doesn't run its Event Loop, the event reports will pile up in the queue, never getting serviced and never releasing their memory. This will appear in the logs as event queue growth warnings.</p>
<p>If a client starts its own thread (e.g., by calling <a class="el" href="le__thread_8h.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create()</a> ), then that thread will <b>not</b> automatically run an Event Loop. To make it run an Event Loop, it must call <code><a class="el" href="le__event_loop_8h.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop()</a></code> (which will never return).</p>
<p>If a thread running an Event Loop terminates, the Legato framework automatically deregisters any handlers and deletes the thread's Event Loop, its Event Queue, and any event reports still in that Event Queue.</p>
<p>Monitoring a file descriptor is performed by the Event Loop of the thread that created the Monitor object for that file descriptor. If that thread is blocked, no events will be detected for that file descriptor until that thread is unblocked and returns to its Event Loop. Likewise, if the thread that creates a File Descriptor Monitor object does not run an Event Loop at all, no events will be detected for that file descriptor.</p>
<p>It's not recommended to use the same file descriptor to monitor two threads at the same time.</p>
<h1><a class="anchor" id="c_event_troubleshooting"></a>
Troubleshooting</h1>
<p>A logging keyword can be enabled to view a given thread's event handling activity. The keyword name depends on the thread and process name where the thread is located. For example, the keyword "P/T/events" controls logging for a thread named "T" running inside a process named "P".</p>
<h1><a class="anchor" id="c_event_integratingLegacyPosix"></a>
Integrating with Legacy POSIX Code</h1>
<p>Many legacy programs written on top of POSIX APIs will have previously built their own event loop using poll(), select(), or some other blocking functions. It may be difficult to refactor this type of event loop to use the Legato event loop instead.</p>
<p>Two functions are provided to assist integrating legacy code with the Legato Event Loop:</p>
<ul>
<li><code><a class="el" href="le__event_loop_8h.html#a12ce7f92f4bc6f5167d5a6ef86d7d0b1">le_event_GetFd()</a></code> - Fetches a file descriptor that can be monitored using some variant of poll() or select() (including epoll). It will appear readable when the Event Loop needs servicing.</li>
<li><code><a class="el" href="le__event_loop_8h.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a></code> - Services the event loop. This should be called if the file descriptor returned by <a class="el" href="le__event_loop_8h.html#a12ce7f92f4bc6f5167d5a6ef86d7d0b1">le_event_GetFd()</a> appears readable to poll() or select().</li>
</ul>
<p>In an attempt to avoid starving the caller when there are a lot of things that need servicing on the Event Loop, <code><a class="el" href="le__event_loop_8h.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a></code> will only perform one servicing step (i.e., call one event handler function) before returning, regardless of how much work there is to do. It's the caller's responsibility to check the return code from <a class="el" href="le__event_loop_8h.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a> and keep calling until it indicates that there is no more work to be done.</p>
<hr/>
<p>Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="http://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.6
        </div>
    </div>
</body>
</html>
