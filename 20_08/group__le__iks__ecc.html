<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html data-context="Build Apps" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>le_iks_ecc API Reference - Legato Docs</title>
<meta content="legato™ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description"/>
<meta content="legato, iot" name="keywords"/>
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="20.08.0" name="legato-version"/>
<link href="resources/images/legato.ico" rel="shortcut icon"/>
<link href="resources/images/legato.ico" rel="icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="apple-touch-icon" type="image/x-icon"/>
<link href="resources/css/style.css" media="screen" rel="stylesheet" type="text/css"/>
<link href="resources/css/font-awesome.css" rel="stylesheet" type="text/css"/>
<!--[if IE]>
        <script src="resources/js/html5shiv.js"></script>
        <script src="resources/js/respond.js"></script>
        <![endif]-->
<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="resources/js/main.js"></script>
<script src="tocs/Build_Apps_API_Guides.json"></script>
</head>
<body>
<noscript>
<input class="modal-closing-trick" id="modal-closing-trick" type="checkbox"/>
<div id="nojs">
<label for="modal-closing-trick">
<span>You seem to not have Javascript <a href="http://enable-javascript.com">enabled</a>, so site functionality like the search and navigation tree won't work.</span>
</label>
</div>
</noscript>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/">Introduction</a><a class="navlink selected" href="buildAppsMain.html">Build Apps</a><a class="navlink" href="buildPlatformMain.html">Build Platform</a><a class="navlink" href="aboutMain.html">About</a>
</nav>
</header>
</div>
<div class="white" id="menudocumentation">
<header>
<a href="/"> <img alt="Back to Legato Homepage" id="logo" src="resources/images/legato_logo.png"/></a>
<h2>/ Build Apps</h2>
<nav class="secondary">
<a href="getStarted.html">Get Started</a><a href="concepts.html">Concepts</a><a class="link-selected" href="apiGuidesMain.html">API Guides</a><a href="tools.html">Tools</a><a href="howToMain.html">How To</a><a href="experimentalMain.html">Experimental Features</a>
</nav>
<nav class="ui-front">
<i class="fa fa-search" id="search-icon"></i>
<input id="searchbox" placeholder="Search"/>
</nav>
</header>
</div>
<div id="resizable">
<div id="left">
<div id="tree1"></div>
</div>
</div>
<div class="content">
<div class="header">
<div class="summary">
<a href="#files">Files</a> |
<a href="#define-members">Macros</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<h1 class="title">le_iks_ecc API Reference</h1> </div>
</div><div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:le__iks__ecc__common_8h"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="le__iks__ecc__common_8h.html">le_iks_ecc_common.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:le__iks__ecc__interface_8h"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="le__iks__ecc__interface_8h.html">le_iks_ecc_interface.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga29f65b9ec39fb4e38b0e3c1dd6f78469"><td align="right" class="memItemLeft" valign="top">#define </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga29f65b9ec39fb4e38b0e3c1dd6f78469">LE_IKS_ECC_MAX_SERIAL_KEY_SIZE</a>   1025</td></tr>
<tr class="separator:ga29f65b9ec39fb4e38b0e3c1dd6f78469"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga522c7ac708c94536d6a7de69f896c435"><td align="right" class="memItemLeft" valign="top">#define </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga522c7ac708c94536d6a7de69f896c435">LE_IKS_ECC_MAX_SIGNATURE_SIZE</a>   1024</td></tr>
<tr class="separator:ga522c7ac708c94536d6a7de69f896c435"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8a0ca4ef47fb581a75912f70cced7d34"><td align="right" class="memItemLeft" valign="top">#define </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga8a0ca4ef47fb581a75912f70cced7d34">LE_IKS_ECC_MAX_TAG_SIZE</a>   64</td></tr>
<tr class="separator:ga8a0ca4ef47fb581a75912f70cced7d34"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad82aa2694f74c13f685a87216b9bed26"><td align="right" class="memItemLeft" valign="top">typedef void(* </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gad82aa2694f74c13f685a87216b9bed26">le_iks_ecc_DisconnectHandler_t</a>) (void *)</td></tr>
<tr class="separator:gad82aa2694f74c13f685a87216b9bed26"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga98a27cd149619fd82ea3e05be9a0f5dd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga98a27cd149619fd82ea3e05be9a0f5dd">le_iks_ecc_ConnectService</a> (void)</td></tr>
<tr class="separator:ga98a27cd149619fd82ea3e05be9a0f5dd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab2614730dc2102f020d24813ecb95b2f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gab2614730dc2102f020d24813ecb95b2f">le_iks_ecc_TryConnectService</a> (void)</td></tr>
<tr class="separator:gab2614730dc2102f020d24813ecb95b2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga560df0e731841cf1590ab55557c08904"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__apiFeatures_8h.html#a410b5eb5dc002cff21fffc3d61d29532">LE_FULL_API</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga560df0e731841cf1590ab55557c08904">le_iks_ecc_SetServerDisconnectHandler</a> (<a class="el" href="group__le__iks__ecc.html#gad82aa2694f74c13f685a87216b9bed26">le_iks_ecc_DisconnectHandler_t</a> disconnectHandler, void *contextPtr)</td></tr>
<tr class="separator:ga560df0e731841cf1590ab55557c08904"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga301e1dcb1fb0bc2cf3c7fe9aad406537"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga301e1dcb1fb0bc2cf3c7fe9aad406537">le_iks_ecc_DisconnectService</a> (void)</td></tr>
<tr class="separator:ga301e1dcb1fb0bc2cf3c7fe9aad406537"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gade9c266c8b2bbccc1da5078f0d623390"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gade9c266c8b2bbccc1da5078f0d623390">le_iks_ecc_Ecdh_GetSharedSecret</a> (uint64_t privKeyRef, uint64_t pubKeyRef, uint8_t *secretPtr, size_t *secretSizePtr)</td></tr>
<tr class="separator:gade9c266c8b2bbccc1da5078f0d623390"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga95475abc7fbcd2ea52e5162aec70a36f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga95475abc7fbcd2ea52e5162aec70a36f">le_iks_ecc_Ecdsa_GenSig</a> (uint64_t keyRef, const uint8_t *digestPtr, size_t digestSize, uint8_t *signaturePtr, size_t *signatureSizePtr)</td></tr>
<tr class="separator:ga95475abc7fbcd2ea52e5162aec70a36f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9730636ead45963ab9e06b7a2383612d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga9730636ead45963ab9e06b7a2383612d">le_iks_ecc_Ecdsa_VerifySig</a> (uint64_t keyRef, const uint8_t *digestPtr, size_t digestSize, const uint8_t *signaturePtr, size_t signatureSize)</td></tr>
<tr class="separator:ga9730636ead45963ab9e06b7a2383612d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab30ac3efb47ce3357fca80502e6fa27c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gab30ac3efb47ce3357fca80502e6fa27c">le_iks_ecc_Ecies_EncryptPacket</a> (uint64_t keyRef, const uint8_t *labelPtr, size_t labelSize, const uint8_t *aadPtr, size_t aadSize, const uint8_t *plaintextPtr, size_t plaintextSize, uint8_t *ciphertextPtr, size_t *ciphertextSizePtr, uint8_t *ephemKeyPtr, size_t *ephemKeySizePtr, uint8_t *saltPtr, size_t *saltSizePtr, uint8_t *tagPtr, size_t *tagSizePtr)</td></tr>
<tr class="separator:gab30ac3efb47ce3357fca80502e6fa27c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab078edc51b4def834e592c33db7f17bc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gab078edc51b4def834e592c33db7f17bc">le_iks_ecc_Ecies_DecryptPacket</a> (uint64_t keyRef, const uint8_t *labelPtr, size_t labelSize, const uint8_t *aadPtr, size_t aadSize, const uint8_t *ephemKeyPtr, size_t ephemKeySize, const uint8_t *saltPtr, size_t saltSize, const uint8_t *ciphertextPtr, size_t ciphertextSize, uint8_t *plaintextPtr, size_t *plaintextSizePtr, const uint8_t *tagPtr, size_t tagSize)</td></tr>
<tr class="separator:gab078edc51b4def834e592c33db7f17bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabd023304e9205e7623053f9e84bffec9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gabd023304e9205e7623053f9e84bffec9">le_iks_ecc_Ecies_StartEncrypt</a> (uint64_t session, const uint8_t *labelPtr, size_t labelSize, uint8_t *ephemKeyPtr, size_t *ephemKeySizePtr, uint8_t *saltPtr, size_t *saltSizePtr)</td></tr>
<tr class="separator:gabd023304e9205e7623053f9e84bffec9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8ba95a5cbbd1cdafc21618ece6c70064"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga8ba95a5cbbd1cdafc21618ece6c70064">le_iks_ecc_Ecies_ProcessAad</a> (uint64_t session, const uint8_t *aadChunkPtr, size_t aadChunkSize)</td></tr>
<tr class="separator:ga8ba95a5cbbd1cdafc21618ece6c70064"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga51d2e5868ee94636f6eddcc7f09c130b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga51d2e5868ee94636f6eddcc7f09c130b">le_iks_ecc_Ecies_Encrypt</a> (uint64_t session, const uint8_t *plaintextChunkPtr, size_t plaintextChunkSize, uint8_t *ciphertextChunkPtr, size_t *ciphertextChunkSizePtr)</td></tr>
<tr class="separator:ga51d2e5868ee94636f6eddcc7f09c130b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga629d4d88025f1da22b4197d1f7a638c8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga629d4d88025f1da22b4197d1f7a638c8">le_iks_ecc_Ecies_DoneEncrypt</a> (uint64_t session, uint8_t *tagPtr, size_t *tagSizePtr)</td></tr>
<tr class="separator:ga629d4d88025f1da22b4197d1f7a638c8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga71e822e6918c1b3c8f3eb155744e5eee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga71e822e6918c1b3c8f3eb155744e5eee">le_iks_ecc_Ecies_StartDecrypt</a> (uint64_t session, const uint8_t *labelPtr, size_t labelSize, const uint8_t *ephemKeyPtr, size_t ephemKeySize, const uint8_t *saltPtr, size_t saltSize)</td></tr>
<tr class="separator:ga71e822e6918c1b3c8f3eb155744e5eee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa0211d95b2e3e8eab24a377657229423"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#gaa0211d95b2e3e8eab24a377657229423">le_iks_ecc_Ecies_Decrypt</a> (uint64_t session, const uint8_t *ciphertextChunkPtr, size_t ciphertextChunkSize, uint8_t *plaintextChunkPtr, size_t *plaintextChunkSizePtr)</td></tr>
<tr class="separator:gaa0211d95b2e3e8eab24a377657229423"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5dfe47797fba8244b3bb8c6a47cbe6a5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__le__iks__ecc.html#ga5dfe47797fba8244b3bb8c6a47cbe6a5">le_iks_ecc_Ecies_DoneDecrypt</a> (uint64_t session, const uint8_t *tagPtr, size_t tagSize)</td></tr>
<tr class="separator:ga5dfe47797fba8244b3bb8c6a47cbe6a5"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga29f65b9ec39fb4e38b0e3c1dd6f78469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f65b9ec39fb4e38b0e3c1dd6f78469">◆ </a></span>LE_IKS_ECC_MAX_SERIAL_KEY_SIZE</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">#define LE_IKS_ECC_MAX_SERIAL_KEY_SIZE   1025</td>
</tr>
</table>
</div><div class="memdoc">
<p>Maximum serialized ECC key size. </p>
</div>
</div>
<a id="ga522c7ac708c94536d6a7de69f896c435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga522c7ac708c94536d6a7de69f896c435">◆ </a></span>LE_IKS_ECC_MAX_SIGNATURE_SIZE</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">#define LE_IKS_ECC_MAX_SIGNATURE_SIZE   1024</td>
</tr>
</table>
</div><div class="memdoc">
<p>Maximum signature size. </p>
</div>
</div>
<a id="ga8a0ca4ef47fb581a75912f70cced7d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0ca4ef47fb581a75912f70cced7d34">◆ </a></span>LE_IKS_ECC_MAX_TAG_SIZE</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">#define LE_IKS_ECC_MAX_TAG_SIZE   64</td>
</tr>
</table>
</div><div class="memdoc">
<p>Maximum tag size. </p>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad82aa2694f74c13f685a87216b9bed26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82aa2694f74c13f685a87216b9bed26">◆ </a></span>le_iks_ecc_DisconnectHandler_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef void(* le_iks_ecc_DisconnectHandler_t) (void *)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Type for handler called when a server disconnects. </p>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga98a27cd149619fd82ea3e05be9a0f5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a27cd149619fd82ea3e05be9a0f5dd">◆ </a></span>le_iks_ecc_ConnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_iks_ecc_ConnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Connect the current client thread to the service providing this API. Block until the service is available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client Specific Functions</a>.</p>
<p>This function is created automatically. </p>
</div>
</div>
<a id="ga301e1dcb1fb0bc2cf3c7fe9aad406537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301e1dcb1fb0bc2cf3c7fe9aad406537">◆ </a></span>le_iks_ecc_DisconnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_iks_ecc_DisconnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Disconnect the current client thread from the service providing this API.</p>
<p>Normally, this function doesn't need to be called. After this function is called, there's no longer a connection to the service, and the functions in this API can't be used. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client Specific Functions</a>.</p>
<p>This function is created automatically. </p>
</div>
</div>
<a id="gade9c266c8b2bbccc1da5078f0d623390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9c266c8b2bbccc1da5078f0d623390">◆ </a></span>le_iks_ecc_Ecdh_GetSharedSecret()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecdh_GetSharedSecret </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>privKeyRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>pubKeyRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>secretPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>secretSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Generate a shared secret between an ECC private key and an ECC public key.</p>
<p>The private key must be of type LE_IKS_KEY_TYPE_PRIV_ECDH and the public must be of type LE_IKS_KEY_TYPE_PUB_ECDH or LE_IKS_KEY_TYPE_PRIV_ECDH.</p>
<p>This function may be used as part of a key exchange protocol. The shared secret is unpredictable (assuming the private portions of both keys are kept secret) but not uniformly distributed and should not be used directly as a cryptographic key.</p>
<p>The shared secret is in the format specified by SEC 1, that is the x component of the shared point converted to an octet string.</p>
<p>If the buffer is too small to hold the shared secret the shared secret will be truncated to fit.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if either key reference is invalid or if either key type is invalid or if two key sizes do not match or if the secretPtr or secretSizePtr is NULL. LE_FAULT if there was an internal error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">privKeyRef</td><td>Private key reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pubKeyRef</td><td>Publid Key reference. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">secretPtr</td><td>Buffer to hold the shared secret. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">secretSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga95475abc7fbcd2ea52e5162aec70a36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95475abc7fbcd2ea52e5162aec70a36f">◆ </a></span>le_iks_ecc_Ecdsa_GenSig()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecdsa_GenSig </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>keyRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>digestPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>digestSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>signaturePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>signatureSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Generate an ECDSA signature on the hash digest of a message.</p>
<p>The key must be a LE_IKS_KEY_TYPE_PRIV_ECDSA key.</p>
<p>The signature is the concatenation of the r and s values (r||s). The size of the signature is twice the key size. For example if the key is 256 bits in size then the signature will be 64 bytes. Note that when the key size is 521 bits, zero-valued high-order padding bits are added to the signature values r and s resulting in a signature of 132 bytes.</p>
<p>The hash function used to generate the message digest should be chosen to match the security strength of the signing key. For example, if the key size is 256 bits then SHA256 (or its equivalent) should be used.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the key reference is invalid or if the key type is invalid or if digestPtr, signaturePtr or signatureSizePtr are NULL LE_OVERFLOW if the signature buffer is too small. LE_FAULT if there was an internal error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">keyRef</td><td>Key reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">digestPtr</td><td>Digest to sign. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">digestSize</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">signaturePtr</td><td>Buffer to hold the signature. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">signatureSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga9730636ead45963ab9e06b7a2383612d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9730636ead45963ab9e06b7a2383612d">◆ </a></span>le_iks_ecc_Ecdsa_VerifySig()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecdsa_VerifySig </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>keyRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>digestPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>digestSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>signaturePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>signatureSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Verifies a signature of the hash digest of a message with ECDSA.</p>
<p>The key must be either a LE_IKS_KEY_TYPE_PUB_ECDSA or LE_IKS_KEY_TYPE_PRIV_ECDSA key.</p>
<p>The signature is the concatenation of the r and s values (r||s). The size of the signature is twice the key size. For example if the key is 256 bits in size then the signature will be 64 bytes. Note that when the key size is 521 bits, zero-valued high-order padding bits are added to the signature values r and s resulting in a signature of 132 bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the key reference is invalid or if the key type is invalid or if either digestPtr or signaturePtr are NULL. LE_FORMAT_ERROR if signatureSize is incorrect. LE_FAULT if the signature is not valid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">keyRef</td><td>Key reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">digestPtr</td><td>Digest of the message. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">digestSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">signaturePtr</td><td>Signature of the message. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">signatureSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gaa0211d95b2e3e8eab24a377657229423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0211d95b2e3e8eab24a377657229423">◆ </a></span>le_iks_ecc_Ecies_Decrypt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_Decrypt </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>ciphertextChunkPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>ciphertextChunkSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>plaintextChunkPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>plaintextChunkSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Decrypt a chunk of ciphertext. Ecies_StartDecrypt() must have been previously called to start a decryption process.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the key type is invalid or if plaintextChunkPtr or ciphertextChunkPtr is NULL. LE_OUT_OF_RANGE if textSize is too big. LE_FAULT if a decryption process has not started. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ciphertextChunkPtr</td><td>Ciphertext chunk. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ciphertextChunkSize</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">plaintextChunkPtr</td><td>Buffer to hold the plaintext chunk. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">plaintextChunkSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gab078edc51b4def834e592c33db7f17bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab078edc51b4def834e592c33db7f17bc">◆ </a></span>le_iks_ecc_Ecies_DecryptPacket()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_DecryptPacket </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>keyRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>labelPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>labelSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>aadPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>aadSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>ephemKeyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>ephemKeySize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>saltPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>saltSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>ciphertextPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>ciphertextSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>plaintextPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>plaintextSizePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>tagPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>tagSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Decrypts and checks the integrity of a short message with ECIES (Elliptic Curve Integrated Encryption System).</p>
<p>Hybrid encryption combines an asymmetric encryption system with a symmetric encryption system to encrypt messages that can only be decrypted with the holder of the private key. Hybrid encryption is usually accomplished by using a symmetric encryption system to bulk encrypt the message and then using the asymmetric encryption system to encrypt the symmetric key.</p>
<p>ECIES provides hybrid encryption through a method that is more efficient than manually performing the two step process described above. Broadly speaking, ECIES performs a key agreement to generate a shared secret, the shared secret is then used to generate a symmetric key using a KDF (Key Derivation Function). The symmetric key is then used to bulk encrypt the message.</p>
<p>This implementation of ECIES generally follows the SEC 1 standard but supports modernized algorithms for the KDF and bulk encryption.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the key reference is invalid or if the key reference is invalid or if either the ephemKeyPtr, saltPtr, aadPtr, plaintextPtr, ciphertextChunkPtr, tagPtr is NULL when they shouldn't be. LE_OUT_OF_RANGE if the labelSize, aadSize, textSize, tagSize is invalid. LE_OVERFLOW if plaintextPtr buffer is too small. LE_FAULT if there was an internal error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">keyRef</td><td>Key reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelPtr</td><td>Label. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aadPtr</td><td>AAD chunk. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aadSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ephemKeyPtr</td><td>Serialized ephemeral public key. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ephemKeySize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">saltPtr</td><td>Salt. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">saltSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ciphertextPtr</td><td>Ciphertext chunk. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ciphertextSize</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">plaintextPtr</td><td>Buffer to hold the plaintext chunk. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">plaintextSizePtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tagPtr</td><td>Authentication tag. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tagSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga5dfe47797fba8244b3bb8c6a47cbe6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dfe47797fba8244b3bb8c6a47cbe6a5">◆ </a></span>le_iks_ecc_Ecies_DoneDecrypt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_DoneDecrypt </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>tagPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>tagSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Complete decryption and verify the integrity.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the key type is invalid or if tagPtr is NULL. LE_FAULT if a decryption process has not started or no data (AAD and ciphertext) has been processed or the integrity check failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tagPtr</td><td>Authentication tag. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tagSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga629d4d88025f1da22b4197d1f7a638c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629d4d88025f1da22b4197d1f7a638c8">◆ </a></span>le_iks_ecc_Ecies_DoneEncrypt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_DoneEncrypt </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>tagPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>tagSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Complete encryption and calculate the authentication tag.</p>
<p>The maximum tag size depends on the symmetric algorithm used. If the supplied buffer is larger than or equal to the maximum authentication tag size then the full authentication tag is copied to the buffer and the rest of the buffer is left unmodified. If the supplied buffer is smaller than the maximum tag size then the tag will be truncated. However, all tags produced using the same key must use the same tag size. It is up to the caller to ensure this.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the key type is invalid or if tagPtr is NULL. LE_OVERFLOW if the tagPtr buffer is too small. LE_FAULT if an encryption process has not started or no data (AAD and plaintext) has been processed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">tagPtr</td><td>Buffer to hold the authentication tag. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">tagSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga51d2e5868ee94636f6eddcc7f09c130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d2e5868ee94636f6eddcc7f09c130b">◆ </a></span>le_iks_ecc_Ecies_Encrypt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_Encrypt </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>plaintextChunkPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>plaintextChunkSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>ciphertextChunkPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>ciphertextChunkSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Encrypt a chunk of plaintext. Ecies_StartEncrypt() must have been previously called to start an encryption process.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the key type is invalid or if plaintextChunkPtr or ciphertextChunkPtr is NULL. LE_OUT_OF_RANGE if textSize is too big. LE_FAULT if an encryption process has not started. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">plaintextChunkPtr</td><td>Plaintext chunk. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">plaintextChunkSize</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ciphertextChunkPtr</td><td>Buffer to hold the ciphertext chunk. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">ciphertextChunkSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gab30ac3efb47ce3357fca80502e6fa27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30ac3efb47ce3357fca80502e6fa27c">◆ </a></span>le_iks_ecc_Ecies_EncryptPacket()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_EncryptPacket </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>keyRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>labelPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>labelSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>aadPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>aadSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>plaintextPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>plaintextSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>ciphertextPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>ciphertextSizePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>ephemKeyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>ephemKeySizePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>saltPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>saltSizePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>tagPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>tagSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Encrypts and integrity protects of a short message with ECIES (Elliptic Curve Integrated Encryption System).</p>
<p>Hybrid encryption combines an asymmetric encryption system with a symmetric encryption system to encrypt messages that can only be decrypted with the holder of the private key. Hybrid encryption is usually accomplished by using a symmetric encryption system to bulk encrypt the message and then using the asymmetric encryption system to encrypt the symmetric key.</p>
<p>ECIES provides hybrid encryption through a method that is more efficient than manually performing the two step process described above. Broadly speaking, ECIES performs a key agreement to generate a shared secret, the shared secret is then used to generate a symmetric key using a KDF (Key Derivation Function). The symmetric key is then used to bulk encrypt the message.</p>
<p>This implementation of ECIES generally follows the SEC 1 standard but supports modernized algorithms for the KDF and bulk encryption.</p>
<p>Either plaintextPtr or aadPtr can be NULL but not both.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the key reference is invalid or if the key type is invalid. or if either labelPtr, aadPtr, plaintextPtr, ciphertextPtr, ephemKeyPtr, ephemKeySizePtr, saltPtr, saltSizePtr, tagPtr is NULL when they shouldn't be. LE_OUT_OF_RANGE if the labelSize, aadSize, textSize is invalid. LE_OVERFLOW if either the ciphertextPtr, ephemKeyPtr, saltSizePtr buffer is too small. LE_FAULT if there was an internal error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">keyRef</td><td>Key reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelPtr</td><td>Label. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aadPtr</td><td>AAD chunk. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aadSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">plaintextPtr</td><td>Plaintext chunk. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">plaintextSize</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ciphertextPtr</td><td>Buffer to hold the ciphertext chunk. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">ciphertextSizePtr</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ephemKeyPtr</td><td>Serialized ephemeral public key. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">ephemKeySizePtr</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">saltPtr</td><td>Buffer to hold the salt. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">saltSizePtr</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">tagPtr</td><td>Buffer to hold the authentication tag. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">tagSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga8ba95a5cbbd1cdafc21618ece6c70064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ba95a5cbbd1cdafc21618ece6c70064">◆ </a></span>le_iks_ecc_Ecies_ProcessAad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_ProcessAad </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>aadChunkPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>aadChunkSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Process a chunk of AAD (Additional Authenticated Data). Either Ecies_StartEncrypt() or Ecies_StartDecrypt() must have been previously called to start either an encryption or decryption process.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the key type is invalid or if aadChunkPtr is NULL. LE_OUT_OF_RANGE if aadChunkSize is too big. LE_FAULT if an encryption or decryption process was not started or plaintext/ciphertext processing has already started. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aadChunkPtr</td><td>AAD chunk. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aadChunkSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga71e822e6918c1b3c8f3eb155744e5eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71e822e6918c1b3c8f3eb155744e5eee">◆ </a></span>le_iks_ecc_Ecies_StartDecrypt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_StartDecrypt </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>labelPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>labelSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>ephemKeyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>ephemKeySize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>saltPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>saltSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Starts a process to decrypt and check the integrity of a message with ECIES (Elliptic Curve Integrated Encryption System).</p>
<p>Hybrid encryption combines an asymmetric encryption system with a symmetric encryption system to encrypt (possibly long) messages that can only be decrypted with the holder of the private key. Hybrid encryption is usually accomplished by using a symmetric encryption system to bulk encrypt the message and then using the asymmetric encryption system to encrypt the symmetric key.</p>
<p>ECIES provides hybrid encryption through a method that is more efficient than manually performing the two step process described above. Broadly speaking, ECIES performs a key agreement to generate a shared secret, the shared secret is then used to generate a symmetric key using a KDF (Key Derivation Function). The symmetric key is then used to bulk encrypt the message.</p>
<p>This implementation of ECIES generally follows the SEC 1 standard but supports modernized algorithms for the KDF and bulk encryption.</p>
<p>To decrypt a long packet the following sequence should be used:</p>
<p>Ecies_StartDecrypt() // Start the decryption process. Ecies_ProcessAad() // Call zero or more times until all AAD data is processed. Ecies_Decrypt() // Call zero or more times until all ciphertext is decrypted. Ecies_DoneDecrypt() // Complete the process and check the authentication tag.</p>
<p>Calling this function will cancel any previously started process using the same session.</p>
<p>The same label, ephemeral public key and salt used for encryption must be provided.</p>
<dl class="section warning"><dt>Warning</dt><dd>While decrypting long packets in this 'streaming' fashion plaintext chunks are released to the caller before they are verified for integrity. Ie. the caller will not know the plaintext is correct until DoneDecrypt() is called. The caller therefore must not release or make use of any plaintext chunks until after DoneDecrypt() returns with LE_OK.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the session key type or ephemeral key is invalid or if either the ephemKeyPtr or saltPtr is NULL. LE_OUT_OF_RANGE if either the labelSize is too big or the saltSize or ephemKeySize is incorrect. LE_FAULT if there was an internal error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelPtr</td><td>Label. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelSize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ephemKeyPtr</td><td>Serialized ephemeral public key. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ephemKeySize</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">saltPtr</td><td>Salt. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">saltSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gabd023304e9205e7623053f9e84bffec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd023304e9205e7623053f9e84bffec9">◆ </a></span>le_iks_ecc_Ecies_StartEncrypt()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_Ecies_StartEncrypt </td>
<td>(</td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>session</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>labelPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>labelSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>ephemKeyPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>ephemKeySizePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>saltPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>saltSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Starts a process to encrypt and integrity protect a message with ECIES (Elliptic Curve Integrated Encryption System).</p>
<p>Hybrid encryption combines an asymmetric encryption system with a symmetric encryption system to encrypt messages that can only be decrypted with the holder of the private key. Hybrid encryption is usually accomplished by using a symmetric encryption system to bulk encrypt the message and then using the asymmetric encryption system to encrypt the symmetric key.</p>
<p>This implementation of ECIES generally follows the SEC 1 standard but supports modernized algorithms for the KDF and bulk encryption.</p>
<p>To encrypt a long packet the following sequence should be used:</p>
<p>Ecies_StartEncrypt() // Start the encryption process. Ecies_ProcessAad() // Call zero or more times until all AAD data is processed. Ecies_Encrypt() // Call zero or more times until all plaintext is encrypted. Ecies_DoneEncrypt() // Complete the process and obtain the authentication tag.</p>
<p>Calling this function will cancel any previously started process using the same session.</p>
<p>The session must have been created with the public key used for encryption.</p>
<p>The AAD and plaintext are optional but they cannot both be omitted. All AAD must be processed before plaintext processing begins.</p>
<p>An optional label associated with the message can be added.</p>
<p>The public portion of the ephemeral key used during the encrytion process is stored in the ephemKeyPtr buffer. It is encoded as an ECPoint as described in RFC5480.</p>
<p>A random salt is used during the encryption process only if the KDF requires it. Currently, only HKDF requires a salt. If present the salt will be the same size as the hash function output size. If no salt is used saltPtr is set to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_BAD_PARAMETER if the session reference is invalid or if the key type is invalid or if either the ephemKeyPtr, ephemKeySizePtr, saltPtr or saltSizePtr is NULL. LE_OUT_OF_RANGE if the labelSize is too big. LE_OVERFLOW if any of the output buffers are too small. LE_FAULT if there was an internal error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelPtr</td><td>Label. NULL if not used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">labelSize</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ephemKeyPtr</td><td>Serialized ephemeral public key. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">ephemKeySizePtr</td><td></td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">saltPtr</td><td>Buffer to hold the salt. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">saltSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga560df0e731841cf1590ab55557c08904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga560df0e731841cf1590ab55557c08904">◆ </a></span>le_iks_ecc_SetServerDisconnectHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__apiFeatures_8h.html#a410b5eb5dc002cff21fffc3d61d29532">LE_FULL_API</a> void le_iks_ecc_SetServerDisconnectHandler </td>
<td>(</td>
<td class="paramtype"><a class="el" href="group__le__iks__ecc.html#gad82aa2694f74c13f685a87216b9bed26">le_iks_ecc_DisconnectHandler_t</a> </td>
<td class="paramname"><em>disconnectHandler</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set handler called when server disconnection is detected.</p>
<p>When a server connection is lost, call this handler then exit with LE_FATAL. If a program wants to continue without exiting, it should call longjmp() from inside the handler. </p>
</div>
</div>
<a id="gab2614730dc2102f020d24813ecb95b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2614730dc2102f020d24813ecb95b2f">◆ </a></span>le_iks_ecc_TryConnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_iks_ecc_TryConnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Try to connect the current client thread to the service providing this API. Return with an error if the service is not available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client Specific Functions</a>.</p>
<p>This function is created automatically.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if the client connected successfully to the service.</li>
<li>LE_UNAVAILABLE if the server is not currently offering the service to which the client is bound.</li>
<li>LE_NOT_PERMITTED if the client interface is not bound to any service (doesn't have a binding).</li>
<li>LE_COMM_ERROR if the Service Directory cannot be reached. </li>
</ul>
</dd></dl>
</div>
</div>
</div>
<br clear="left"/>
</div>
</div>
<link href="resources/css/jqtree.css" rel="stylesheet" type="text/css"/>
<script src="resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<link href="resources/css/perfect-scrollbar.min.css" rel="stylesheet"/>
<script src="resources/js/perfect-scrollbar.jquery.min.js"></script>
</body>
</html>
