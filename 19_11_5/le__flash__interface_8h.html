<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html data-context="Build Apps" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>le_flash_interface.h File Reference - Legato Docs</title>
<meta content="legato™ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description"/>
<meta content="legato, iot" name="keywords"/>
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="19.11.5" name="legato-version"/>
<link href="resources/images/legato.ico" rel="shortcut icon"/>
<link href="resources/images/legato.ico" rel="icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="resources/images/legato.ico" rel="apple-touch-icon" type="image/x-icon"/>
<link href="resources/css/style.css" media="screen" rel="stylesheet" type="text/css"/>
<link href="resources/css/font-awesome.css" rel="stylesheet" type="text/css"/>
<!--[if IE]>
    <script src="resources/js/html5shiv.js"></script>
    <script src="resources/js/respond.js"></script>
  <![endif]-->
<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="resources/js/main.js"></script>
<script src="tocs/Build_Apps_API_Guides.json"></script>
</head>
<body>
<noscript>
<input class="modal-closing-trick" id="modal-closing-trick" type="checkbox"/>
<div id="nojs">
<label for="modal-closing-trick">
<span>You seem to not have Javascript <a href="http://enable-javascript.com">enabled</a>, so site functionality like the search and navigation tree won't work.</span>
</label>
</div>
</noscript>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/">Introduction</a><a class="navlink selected" href="buildAppsMain.html">Build Apps</a><a class="navlink" href="buildPlatformMain.html">Build Platform</a><a class="navlink" href="aboutMain.html">About</a>
</nav>
</header>
</div>
<div class="white" id="menudocumentation">
<header>
<a href="/"> <img alt="Back to Legato Homepage" id="logo" src="resources/images/legato_logo.png"/></a>
<h2>/ Build Apps</h2>
<nav class="secondary">
<a href="getStarted.html">Get Started</a><a href="concepts.html">Concepts</a><a class="link-selected" href="apiGuidesMain.html">API Guides</a><a href="tools.html">Tools</a><a href="howToMain.html">How To</a><a href="experimentalMain.html">Experimental Features</a>
</nav>
<nav class="ui-front">
<i class="fa fa-search" id="search-icon"></i>
<input id="searchbox" placeholder="Search"/>
</nav>
</header>
</div>
<div id="resizable">
<div id="left">
<div id="tree1"></div>
</div>
</div>
<div class="content">
<div class="header">
<div class="summary">
<a href="#typedef-members">Typedefs</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<h1 class="title">le_flash_interface.h File Reference</h1> </div>
</div><div class="contents">
<div class="textblock"><code>#include "legato.h"</code><br/>
<code>#include "le_flash_common.h"</code><br/>
</div>
<p><a href="le__flash__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a05155447383d2c0ff254170f4f63ff01"><td align="right" class="memItemLeft" valign="top">typedef void(* </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a05155447383d2c0ff254170f4f63ff01">le_flash_DisconnectHandler_t</a>) (void *)</td></tr>
<tr class="separator:a05155447383d2c0ff254170f4f63ff01"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54bc299ab07842170f062e5ab7a13d11"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a54bc299ab07842170f062e5ab7a13d11">le_flash_ConnectService</a> (void)</td></tr>
<tr class="separator:a54bc299ab07842170f062e5ab7a13d11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b3e2c090f38b2869bbba6e7d3899c14"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a1b3e2c090f38b2869bbba6e7d3899c14">le_flash_TryConnectService</a> (void)</td></tr>
<tr class="separator:a1b3e2c090f38b2869bbba6e7d3899c14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6d73f53d82de74affadca954c81db011"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__apiFeatures_8h.html#a410b5eb5dc002cff21fffc3d61d29532">LE_FULL_API</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a6d73f53d82de74affadca954c81db011">le_flash_SetServerDisconnectHandler</a> (<a class="el" href="le__flash__interface_8h.html#a05155447383d2c0ff254170f4f63ff01">le_flash_DisconnectHandler_t</a> disconnectHandler, void *contextPtr)</td></tr>
<tr class="separator:a6d73f53d82de74affadca954c81db011"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2317ee626cffbe20200d329db2c5bebe"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a2317ee626cffbe20200d329db2c5bebe">le_flash_DisconnectService</a> (void)</td></tr>
<tr class="separator:a2317ee626cffbe20200d329db2c5bebe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a95574e6e395ef5dc5877ebf9b4e2a19f"><td align="right" class="memItemLeft" valign="top">le_flash_BadImageDetectionHandlerRef_t </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a95574e6e395ef5dc5877ebf9b4e2a19f">le_flash_AddBadImageDetectionHandler</a> (le_flash_BadImageDetectionHandlerFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr class="separator:a95574e6e395ef5dc5877ebf9b4e2a19f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9e395cd7955381a119bd353cc1023554"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a9e395cd7955381a119bd353cc1023554">le_flash_RemoveBadImageDetectionHandler</a> (le_flash_BadImageDetectionHandlerRef_t handlerRef)</td></tr>
<tr class="separator:a9e395cd7955381a119bd353cc1023554"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b1c0d8884bfe843dd33a2ac25e4bf3f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a5b1c0d8884bfe843dd33a2ac25e4bf3f">le_flash_RequestAccess</a> (void)</td></tr>
<tr class="separator:a5b1c0d8884bfe843dd33a2ac25e4bf3f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a935bb23268e1311fa6d9d0fb0e90606a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a935bb23268e1311fa6d9d0fb0e90606a">le_flash_ReleaseAccess</a> (void)</td></tr>
<tr class="separator:a935bb23268e1311fa6d9d0fb0e90606a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a201ac5e6437c377c2c77ac25a0b0e0f0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a201ac5e6437c377c2c77ac25a0b0e0f0">le_flash_OpenMtd</a> (const char *LE_NONNULL partitionName, le_flash_OpenMode_t mode, le_flash_PartitionRef_t *partitionRefPtr)</td></tr>
<tr class="separator:a201ac5e6437c377c2c77ac25a0b0e0f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a952dd12d255eca1b408b15465256c8f7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a952dd12d255eca1b408b15465256c8f7">le_flash_OpenUbi</a> (const char *LE_NONNULL partitionName, le_flash_OpenMode_t mode, le_flash_PartitionRef_t *partitionRefPtr)</td></tr>
<tr class="separator:a952dd12d255eca1b408b15465256c8f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a30777595484051e349c41005cbe567a1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a30777595484051e349c41005cbe567a1">le_flash_OpenUbiVolume</a> (le_flash_PartitionRef_t partitionRef, const char *LE_NONNULL volumeName, int32_t volumeSize)</td></tr>
<tr class="separator:a30777595484051e349c41005cbe567a1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a775b88378bd1e99ac9fc7578eb45ea45"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a775b88378bd1e99ac9fc7578eb45ea45">le_flash_CloseUbiVolume</a> (le_flash_PartitionRef_t partitionRef)</td></tr>
<tr class="separator:a775b88378bd1e99ac9fc7578eb45ea45"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad35822ce512be4c76ede295618fd292f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#ad35822ce512be4c76ede295618fd292f">le_flash_Close</a> (le_flash_PartitionRef_t partitionRef)</td></tr>
<tr class="separator:ad35822ce512be4c76ede295618fd292f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7cf4492e183d50c6acd91a09dd8e379"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#aa7cf4492e183d50c6acd91a09dd8e379">le_flash_EraseBlock</a> (le_flash_PartitionRef_t partitionRef, uint32_t blockIndex)</td></tr>
<tr class="separator:aa7cf4492e183d50c6acd91a09dd8e379"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeade27f3e79bc31562f03a55c2720205"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#aeade27f3e79bc31562f03a55c2720205">le_flash_Read</a> (le_flash_PartitionRef_t partitionRef, uint32_t blockIndex, uint8_t *readDataPtr, size_t *readDataSizePtr)</td></tr>
<tr class="separator:aeade27f3e79bc31562f03a55c2720205"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4710e671736b31623bde38a0a45dd6be"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a4710e671736b31623bde38a0a45dd6be">le_flash_Write</a> (le_flash_PartitionRef_t partitionRef, uint32_t blockIndex, const uint8_t *writeDataPtr, size_t writeDataSize)</td></tr>
<tr class="separator:a4710e671736b31623bde38a0a45dd6be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62fb368ac8627c1757ca7003d93753e7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a62fb368ac8627c1757ca7003d93753e7">le_flash_GetBlockInformation</a> (le_flash_PartitionRef_t partitionRef, uint32_t *badBlocksNumberPtr, uint32_t *eraseBlocksNumberPtr, uint32_t *eraseBlockSizePtr, uint32_t *pageSizePtr)</td></tr>
<tr class="separator:a62fb368ac8627c1757ca7003d93753e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac83627b7aac9aef8f2a921b0d210771d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#ac83627b7aac9aef8f2a921b0d210771d">le_flash_GetUbiVolumeInformation</a> (le_flash_PartitionRef_t partitionRef, uint32_t *freeBlockNumberPtr, uint32_t *allocatedBlockNumberPtr, uint32_t *sizeInBytesPtr)</td></tr>
<tr class="separator:ac83627b7aac9aef8f2a921b0d210771d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac89478424c0faf00d59dbfe0c5d135ac"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#ac89478424c0faf00d59dbfe0c5d135ac">le_flash_CreateUbi</a> (const char *LE_NONNULL partitionName, bool isForcedCreate, le_flash_PartitionRef_t *partitionRefPtr)</td></tr>
<tr class="separator:ac89478424c0faf00d59dbfe0c5d135ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a821742a3f7ae388b6a337917cc5ee176"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a821742a3f7ae388b6a337917cc5ee176">le_flash_CreateUbiVolume</a> (le_flash_PartitionRef_t partitionRef, bool isForcedCreate, uint32_t volumeID, le_flash_UbiVolumeType_t volumeType, const char *LE_NONNULL volumeName, int32_t volumeSize)</td></tr>
<tr class="separator:a821742a3f7ae388b6a337917cc5ee176"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3878530d7d57eb120267d34c67d5d163"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="le__flash__interface_8h.html#a3878530d7d57eb120267d34c67d5d163">le_flash_DeleteUbiVolume</a> (le_flash_PartitionRef_t partitionRef, const char *LE_NONNULL volumeName)</td></tr>
<tr class="separator:a3878530d7d57eb120267d34c67d5d163"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_flash.html">Flash API</a> include file.</p>
<p class="copyright">Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a05155447383d2c0ff254170f4f63ff01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05155447383d2c0ff254170f4f63ff01">◆ </a></span>le_flash_DisconnectHandler_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef void(* le_flash_DisconnectHandler_t) (void *)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Type for handler called when a server disconnects. </p>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a95574e6e395ef5dc5877ebf9b4e2a19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95574e6e395ef5dc5877ebf9b4e2a19f">◆ </a></span>le_flash_AddBadImageDetectionHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">le_flash_BadImageDetectionHandlerRef_t le_flash_AddBadImageDetectionHandler </td>
<td>(</td>
<td class="paramtype">le_flash_BadImageDetectionHandlerFunc_t </td>
<td class="paramname"><em>handlerPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Open mode. UBI volume type mode. Declare a reference type for referring a partition. Handler for bad image detection.</p>
<dl class="section note"><dt>Note</dt><dd>The image names are platform dependent. Reference type used by Add/Remove functions for EVENT 'le_flash_BadImageDetection' Add handler function for EVENT 'le_flash_BadImageDetection'</dd></dl>
<p>This event provides information on bad image status. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad35822ce512be4c76ede295618fd292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35822ce512be4c76ede295618fd292f">◆ </a></span>le_flash_Close()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_Close </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Close a flash partition</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference to be closed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a775b88378bd1e99ac9fc7578eb45ea45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775b88378bd1e99ac9fc7578eb45ea45">◆ </a></span>le_flash_CloseUbiVolume()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_CloseUbiVolume </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Close the used UBI volume of an UBI image.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a54bc299ab07842170f062e5ab7a13d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bc299ab07842170f062e5ab7a13d11">◆ </a></span>le_flash_ConnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_flash_ConnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Connect the current client thread to the service providing this API. Block until the service is available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically. </p>
</div>
</div>
<a id="ac89478424c0faf00d59dbfe0c5d135ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89478424c0faf00d59dbfe0c5d135ac">◆ </a></span>le_flash_CreateUbi()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_CreateUbi </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>partitionName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>isForcedCreate</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_flash_PartitionRef_t * </td>
<td class="paramname"><em>partitionRefPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create an UBI partition. If the partition is already an UBI, an error is raised except if the flag isForcedCreate is set to true. In this case, the whole UBI partition is recreated and the previous content is lost. If the operation succeed, the partition is opened in write-only and this is not necessary to call <a class="el" href="le__flash__interface_8h.html#a952dd12d255eca1b408b15465256c8f7">le_flash_OpenUbi()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_NOT_FOUND If the flash partition is not found</li>
<li>LE_DUPLICATE If the partition is already an UBI partition and isForcedCreate is not set to true</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionName</td><td>Partition to be opened. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">isForcedCreate</td><td>Force the UBI recreation and overwrite the previous content. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">partitionRefPtr</td><td>Partition reference. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a821742a3f7ae388b6a337917cc5ee176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821742a3f7ae388b6a337917cc5ee176">◆ </a></span>le_flash_CreateUbiVolume()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_CreateUbiVolume </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>isForcedCreate</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>volumeID</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_flash_UbiVolumeType_t </td>
<td class="paramname"><em>volumeType</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>volumeName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t </td>
<td class="paramname"><em>volumeSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a new UBI volume into an UBI partition. If the volume name or the volume ID already exists, an error is raised except if the flag isForcedCreate is set to true. In this case, the whole UBI volume is recreated and the previous content is lost. If the operation succeed, UBI volume is opened and this is not necessary to call <a class="el" href="le__flash__interface_8h.html#a30777595484051e349c41005cbe567a1">le_flash_OpenUbiVolume()</a>. Note that the UBI partition should be opened in write-only or read-write mode, else an error is raised. The volumeName is the same parameter as <a class="el" href="le__flash__interface_8h.html#a30777595484051e349c41005cbe567a1">le_flash_OpenUbiVolume()</a>. A static volume cannot be extended when mounted, so it is generally used for SQUASHFS or others immutables and R/O filesystems. A dynamic volume is extensible like UBIFS volumes. The volume ID is the number of the UBI volume to be created. If set to NO_UBI_VOLUME_ID, the first free volume ID will be used.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_NOT_PERMITTED If the UBI partition is not opened in write-only or read-write mode</li>
<li>LE_DUPLICATE If the UBI volume already exists with a same name or a same volume ID and isForcedCreate is not set to true</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">isForcedCreate</td><td>Force the UBI volume recreation and overwrite the previous content. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeID</td><td>Volume ID to set. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeType</td><td>Volume type to set. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeName</td><td>Volume name to be created. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeSize</td><td>Volume size to set. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a3878530d7d57eb120267d34c67d5d163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3878530d7d57eb120267d34c67d5d163">◆ </a></span>le_flash_DeleteUbiVolume()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_DeleteUbiVolume </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>volumeName</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Delete an UBI volume from an UBI partition. If the volume is currently opened by <a class="el" href="le__flash__interface_8h.html#a30777595484051e349c41005cbe567a1">le_flash_OpenUbiVolume()</a>, it is closed first. Note that the UBI partition should be opened in write-only or read-write mode, else an error is raised.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_NOT_PERMITTED If the UBI partition is not open in write-only or read-write mode</li>
<li>LE_NOT_FOUND If the volume name is not found</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeName</td><td>Volume name to be deleted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2317ee626cffbe20200d329db2c5bebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2317ee626cffbe20200d329db2c5bebe">◆ </a></span>le_flash_DisconnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_flash_DisconnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Disconnect the current client thread from the service providing this API.</p>
<p>Normally, this function doesn't need to be called. After this function is called, there's no longer a connection to the service, and the functions in this API can't be used. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically. </p>
</div>
</div>
<a id="aa7cf4492e183d50c6acd91a09dd8e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cf4492e183d50c6acd91a09dd8e379">◆ </a></span>le_flash_EraseBlock()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_EraseBlock </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>blockIndex</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Erase a block inside a flash partition. If the erase fails, the block is marked bad.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_FAULT On other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference to be closed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blockIndex</td><td>Logical block index to be erased. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a62fb368ac8627c1757ca7003d93753e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fb368ac8627c1757ca7003d93753e7">◆ </a></span>le_flash_GetBlockInformation()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_GetBlockInformation </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>badBlocksNumberPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>eraseBlocksNumberPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>eraseBlockSizePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>pageSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieve information about the partition opened: the number of bad blocks found inside the partition, the number of erase blocks, the size of the erase block and the size of the page.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_FAULT On other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference to be used. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">badBlocksNumberPtr</td><td>Bad blocks number inside the partition </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">eraseBlocksNumberPtr</td><td>Erase blocks number </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">eraseBlockSizePtr</td><td>Erase block size </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">pageSizePtr</td><td>Page size </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ac83627b7aac9aef8f2a921b0d210771d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83627b7aac9aef8f2a921b0d210771d">◆ </a></span>le_flash_GetUbiVolumeInformation()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_GetUbiVolumeInformation </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>freeBlockNumberPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>allocatedBlockNumberPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t * </td>
<td class="paramname"><em>sizeInBytesPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Retrieve information about the UBI volume opened: the number of free blocks for the UBI, the number of currently allocated blocks to the volume and its real size in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_FAULT On other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference to be used. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">freeBlockNumberPtr</td><td>Free blocks number on the UBI partition </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">allocatedBlockNumberPtr</td><td>Allocated blocks number to the UBI volume </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">sizeInBytesPtr</td><td>Real size in bytes of the UBI volume </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a201ac5e6437c377c2c77ac25a0b0e0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201ac5e6437c377c2c77ac25a0b0e0f0">◆ </a></span>le_flash_OpenMtd()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_OpenMtd </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>partitionName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_flash_OpenMode_t </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_flash_PartitionRef_t * </td>
<td class="paramname"><em>partitionRefPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Open a flash partition at the block layer for the given operation and return a descriptor. The read and write operation will be done using MTD.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_NOT_FOUND If the flash partition is not found</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionName</td><td>Partition to be opened. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Opening mode. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">partitionRefPtr</td><td>Partition reference. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a952dd12d255eca1b408b15465256c8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952dd12d255eca1b408b15465256c8f7">◆ </a></span>le_flash_OpenUbi()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_OpenUbi </td>
<td>(</td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>partitionName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_flash_OpenMode_t </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">le_flash_PartitionRef_t * </td>
<td class="paramname"><em>partitionRefPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Open a UBI volume for the given operation and return a descriptor. The read and write operation will be done using MTD, UBI metadata will be updated.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_NOT_FOUND If the flash partition is not found</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionName</td><td>Partition to be opened. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Opening mode. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">partitionRefPtr</td><td>Partition reference. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a30777595484051e349c41005cbe567a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30777595484051e349c41005cbe567a1">◆ </a></span>le_flash_OpenUbiVolume()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_OpenUbiVolume </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *LE_NONNULL </td>
<td class="paramname"><em>volumeName</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t </td>
<td class="paramname"><em>volumeSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Open the UBI volume of an UBI image to be used for the read and write operations. When open for writing and a volumeSize is given, the UBI volume will be adjusted to this size by freeing the PEBs over this size. If the data inside the volume require more PEBs, they will be added by the <a class="el" href="le__flash__interface_8h.html#a4710e671736b31623bde38a0a45dd6be">le_flash_Write()</a> API.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_NOT_FOUND If the volume name is not found</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeName</td><td>Volume name to be used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">volumeSize</td><td>Volume size to set if open for writing </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aeade27f3e79bc31562f03a55c2720205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeade27f3e79bc31562f03a55c2720205">◆ </a></span>le_flash_Read()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_Read </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>blockIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint8_t * </td>
<td class="paramname"><em>readDataPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t * </td>
<td class="paramname"><em>readDataSizePtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Read data from a flash partition. The read data are:</p><ul>
<li>at the logical block index given by blockIndex.</li>
<li>the maximum read data length is:<ul>
<li>an erase block size for MTD usage partition</li>
<li>an erase block size minus 2 pages for UBI partitions</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_FAULT On other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference to be used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blockIndex</td><td>Logical block index to be read. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">readDataPtr</td><td>Data buffer to copy the read data. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">readDataSizePtr</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a935bb23268e1311fa6d9d0fb0e90606a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935bb23268e1311fa6d9d0fb0e90606a">◆ </a></span>le_flash_ReleaseAccess()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_ReleaseAccess </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Release the flash access requested by le_flash_RequestAccess API.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
</div>
</div>
<a id="a9e395cd7955381a119bd353cc1023554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e395cd7955381a119bd353cc1023554">◆ </a></span>le_flash_RemoveBadImageDetectionHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void le_flash_RemoveBadImageDetectionHandler </td>
<td>(</td>
<td class="paramtype">le_flash_BadImageDetectionHandlerRef_t </td>
<td class="paramname"><em>handlerRef</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove handler function for EVENT 'le_flash_BadImageDetection' </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a5b1c0d8884bfe843dd33a2ac25e4bf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1c0d8884bfe843dd33a2ac25e4bf3f">◆ </a></span>le_flash_RequestAccess()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_RequestAccess </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Request the flash access authorization. This is required to avoid race operations.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_UNAVAILABLE The flash access is temporarily unavailable</li>
<li>LE_DUPLICATE If the a request access for the client was already performed</li>
<li>LE_FAULT On failure </li>
</ul>
</dd></dl>
</div>
</div>
<a id="a6d73f53d82de74affadca954c81db011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d73f53d82de74affadca954c81db011">◆ </a></span>le_flash_SetServerDisconnectHandler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__apiFeatures_8h.html#a410b5eb5dc002cff21fffc3d61d29532">LE_FULL_API</a> void le_flash_SetServerDisconnectHandler </td>
<td>(</td>
<td class="paramtype"><a class="el" href="le__flash__interface_8h.html#a05155447383d2c0ff254170f4f63ff01">le_flash_DisconnectHandler_t</a> </td>
<td class="paramname"><em>disconnectHandler</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>contextPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Set handler called when server disconnection is detected.</p>
<p>When a server connection is lost, call this handler then exit with LE_FATAL. If a program wants to continue without exiting, it should call longjmp() from inside the handler. </p>
</div>
</div>
<a id="a1b3e2c090f38b2869bbba6e7d3899c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3e2c090f38b2869bbba6e7d3899c14">◆ </a></span>le_flash_TryConnectService()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_TryConnectService </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Try to connect the current client thread to the service providing this API. Return with an error if the service is not available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if the client connected successfully to the service.</li>
<li>LE_UNAVAILABLE if the server is not currently offering the service to which the client is bound.</li>
<li>LE_NOT_PERMITTED if the client interface is not bound to any service (doesn't have a binding).</li>
<li>LE_COMM_ERROR if the Service Directory cannot be reached. </li>
</ul>
</dd></dl>
</div>
</div>
<a id="a4710e671736b31623bde38a0a45dd6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4710e671736b31623bde38a0a45dd6be">◆ </a></span>le_flash_Write()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_flash_Write </td>
<td>(</td>
<td class="paramtype">le_flash_PartitionRef_t </td>
<td class="paramname"><em>partitionRef</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>blockIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint8_t * </td>
<td class="paramname"><em>writeDataPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>writeDataSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Write data to a flash partition.</p><ul>
<li>the block is firstly erased, so no call to <a class="el" href="le__flash__interface_8h.html#aa7cf4492e183d50c6acd91a09dd8e379">le_flash_EraseBlock()</a> is needed.</li>
<li>if the erase or the write reports an error, the block is marked "bad" and the write starts again at the next physical block.</li>
<li>the data are programmed at the logical block index given by blockIndex.</li>
<li>the maximum written data length is:<ul>
<li>an erase block size for MTD usage partition. This is the eraseBlockSize returned by le_flash_GetInformation().</li>
<li>an erase block size minus 2 pages for UBI partitions. These are the eraseBlockSize and pageSize returned by le_flash_GetInformation(). If the write addresses an UBI volume and more PEBs are required to write the new data, new PEBs will be added into this volume.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The addressed block is automatically erased before to be written.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK On success</li>
<li>LE_BAD_PARAMETER If a parameter is invalid</li>
<li>LE_FAULT On other error </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">partitionRef</td><td>Partition reference to be used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">blockIndex</td><td>Logical block index to be write. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writeDataPtr</td><td>Data buffer to be written. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writeDataSize</td><td></td></tr>
</table>
</dd>
</dl>
</div>
</div>
</div>
<br clear="left"/>
</div>
</div>
<link href="resources/css/jqtree.css" rel="stylesheet" type="text/css"/>
<script src="resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<link href="resources/css/perfect-scrollbar.min.css" rel="stylesheet"/>
<script src="resources/js/perfect-scrollbar.jquery.min.js"></script>
</body>
</html>
