<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: interfaces/config/c/le_cfg_interface.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Wireless M2M smooth and connected</div>
  </td>
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('le__cfg__interface_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">interfaces/config/c/le_cfg_interface.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br/>
<code>#include &quot;configTypes.h&quot;</code><br/>
</div>
<p><a href="le__cfg__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
le_cfg_ChangeHandler *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#affe352cba8a8cac1f8950901ea47b61c">le_cfg_ChangeHandlerFunc_t</a> )(void *contextPtr)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a5228a4832c56fbec5a6448db814d6a49">le_cfg_StartClient</a> (const char *serviceInstanceName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a04d4fcfe495fe8ff73e7b1bfe9a034a0">le_cfg_StopClient</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_IteratorRef_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aa766bff3a3ddbd2769b903fc56f6d9d2">le_cfg_CreateReadTxn</a> (const char *basePath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_IteratorRef_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9c817e5edf0df97034fdc432ce8d0f18">le_cfg_CreateWriteTxn</a> (const char *basePath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9825af4d2e007d82f4385ee444a348ef">le_cfg_CommitTxn</a> (le_cfg_IteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af5f10497ed85d2e647b41ca460228483">le_cfg_CancelTxn</a> (le_cfg_IteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a3a8519b471bc6f4a5fea3716636dc607">le_cfg_GoToNode</a> (le_cfg_IteratorRef_t iteratorRef, const char *newPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad7d7debfc7c78b3a8b3908fcbc1a5966">le_cfg_GoToParent</a> (le_cfg_IteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#abb7ab8d52ca9bf5e0977341e18740079">le_cfg_GoToFirstChild</a> (le_cfg_IteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aafcdb4bf55c14d960b7d16bb05af4bbe">le_cfg_GoToNextSibling</a> (le_cfg_IteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ab0c67c75671a9d003fa639b5f2ada51f">le_cfg_GetPath</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, char *pathBuffer, size_t pathBufferNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_nodeType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a31df1f796da5a18a74de1110c549d6f8">le_cfg_GetNodeType</a> (le_cfg_IteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a02c84283bc9c62a490e9c7cf3f3d5598">le_cfg_GetNodeName</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, char *name, size_t nameNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a8802d20de7b178e51191c20e74fb495b">le_cfg_SetNodeName</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aa9a19e022625fc2c4a2a39e95ac60936">le_cfg_AddChangeHandler</a> (const char *newPath, <a class="el" href="le__cfg__interface_8h.html#affe352cba8a8cac1f8950901ea47b61c">le_cfg_ChangeHandlerFunc_t</a> handlerPtr, void *contextPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a17fa5e63dd1f5a2b7b66c92a76f8c98a">le_cfg_RemoveChangeHandler</a> (<a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> addHandlerRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a30e8684f89c8e05ca489bc897ab378b9">le_cfg_DeleteNode</a> (le_cfg_IteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a46db89aea45bb59128fba40bde081833">le_cfg_IsEmpty</a> (le_cfg_IteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a008c17822f0af91639b1fbb257be48ea">le_cfg_SetEmpty</a> (le_cfg_IteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a33d4fbe741e6a6ff5377f60e8754d1e4">le_cfg_NodeExists</a> (le_cfg_IteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aabb24e6c90309be03ce5a285d5849658">le_cfg_GetString</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, char *value, size_t valueNumElements, const char *defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a741ade500cc7b10070e45065740d6980">le_cfg_SetString</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, const char *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ada4b5ea73868f3d00701d7e76c2e6f38">le_cfg_GetInt</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, int32_t defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a46cb4c6dd1068cb07128ca637667bb77">le_cfg_SetInt</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, int32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aeb213c2fbf840931ec8c1427ef6b317e">le_cfg_GetFloat</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, double defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aab1e755f81ef2e4bcbc6d57ea558a7a5">le_cfg_SetFloat</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aa3898fcb0d62b03c9a238d36b42d7a63">le_cfg_GetBool</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, bool defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a1b760f2ef78e9c12dc207a5cbe333c99">le_cfg_SetBool</a> (le_cfg_IteratorRef_t iteratorRef, const char *path, bool value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a95f44c1e0d16eb48475465af63300a75">le_cfg_QuickDeleteNode</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ae8fd42cad37a0a5d3ad8072b9571cc97">le_cfg_QuickSetEmpty</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a049b354def8c343930816fd79903e483">le_cfg_QuickGetString</a> (const char *path, char *value, size_t valueNumElements, const char *defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aebf43c4763e9e9d9b305200ace67fdac">le_cfg_QuickSetString</a> (const char *path, const char *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a4503bb519a439f3de35d762668947c45">le_cfg_QuickGetInt</a> (const char *path, int32_t defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aca19ad4032442eb97171769e434d3a60">le_cfg_QuickSetInt</a> (const char *path, int32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#acf4ccdd3b7b18b971768db755b8273fc">le_cfg_QuickGetFloat</a> (const char *path, double defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aea4e34e0d4384f3cf0bb1c3bd27d4133">le_cfg_QuickSetFloat</a> (const char *path, double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a256c22a1fbe25c69a96af37d388c6805">le_cfg_QuickGetBool</a> (const char *path, bool defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad8915472ac5e82a8d3942ae8203264f2">le_cfg_QuickSetBool</a> (const char *path, bool value)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="api_config.html">Configuration Tree API</a></p>
<p>Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="affe352cba8a8cac1f8950901ea47b61c"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_ChangeHandlerFunc_t" ref="affe352cba8a8cac1f8950901ea47b61c" args=")(void *contextPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="le__cfg__interface_8h.html#affe352cba8a8cac1f8950901ea47b61c">le_cfg_ChangeHandlerFunc_t</a>)(void *contextPtr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a call back on a given node object. Once registered, if that node or if any of it's children are read from, written to, created or deleted, then this function will be called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle to the event registration.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contextPtr</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad02e652d8ea74b6e8ebb8125190e5244"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_ChangeHandlerRef_t" ref="ad02e652d8ea74b6e8ebb8125190e5244" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_cfg_ChangeHandler* <a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reference type for le_cfg_ChangeHandler handler ADD/REMOVE functions </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa9a19e022625fc2c4a2a39e95ac60936"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_AddChangeHandler" ref="aa9a19e022625fc2c4a2a39e95ac60936" args="(const char *newPath, le_cfg_ChangeHandlerFunc_t handlerPtr, void *contextPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> <a class="el" href="le__cfg__interface_8h.html#aa9a19e022625fc2c4a2a39e95ac60936">le_cfg_AddChangeHandler</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#affe352cba8a8cac1f8950901ea47b61c">le_cfg_ChangeHandlerFunc_t</a>&#160;</td>
          <td class="paramname"><em>handlerPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>le_cfg_ChangeHandler handler ADD function </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Path to the object to watch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5f10497ed85d2e647b41ca460228483"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CancelTxn" ref="af5f10497ed85d2e647b41ca460228483" args="(le_cfg_IteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#af5f10497ed85d2e647b41ca460228483">le_cfg_CancelTxn</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close and free the given iterator object. If the iterator is a write iterator, the transaction will be canceled. If the iterator is a read iterator, the transaction will be closed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This operation will also delete the iterator object. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9825af4d2e007d82f4385ee444a348ef"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CommitTxn" ref="a9825af4d2e007d82f4385ee444a348ef" args="(le_cfg_IteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a9825af4d2e007d82f4385ee444a348ef">le_cfg_CommitTxn</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the write iterator and commit the write transaction. This updates the config tree with all of the writes that occured using the iterator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This operation will also delete the iterator object. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to commit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa766bff3a3ddbd2769b903fc56f6d9d2"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CreateReadTxn" ref="aa766bff3a3ddbd2769b903fc56f6d9d2" args="(const char *basePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_IteratorRef_t <a class="el" href="le__cfg__interface_8h.html#aa766bff3a3ddbd2769b903fc56f6d9d2">le_cfg_CreateReadTxn</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a read transaction and open a new iterator for traversing the configuration tree.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This action creates a read lock on the given tree. Which will start a read-timeout. Once the read timeout expires, then all active read iterators on that tree will be expired and the clients killed.</dd>
<dd>
: A tree transaction is global to that tree; a long held read transaction will block other users write transactions from being comitted.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This will return a newly created iterator reference. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basePath</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c817e5edf0df97034fdc432ce8d0f18"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CreateWriteTxn" ref="a9c817e5edf0df97034fdc432ce8d0f18" args="(const char *basePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_IteratorRef_t <a class="el" href="le__cfg__interface_8h.html#a9c817e5edf0df97034fdc432ce8d0f18">le_cfg_CreateWriteTxn</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a write transaction and open a new iterator for both reading and writing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This action creates a write transaction. If the application holds the iterator for longer than the configured write transaction timeout, the iterator will cancel the transaction. All further reads will fail to return data and all writes will be thrown away.</dd>
<dd>
A tree transaction is global to that tree, so a long held write transaction will block other user's write transactions from being started. However other trees in the system will be unaffected.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This will return a newly created iterator reference. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basePath</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30e8684f89c8e05ca489bc897ab378b9"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_DeleteNode" ref="a30e8684f89c8e05ca489bc897ab378b9" args="(le_cfg_IteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a30e8684f89c8e05ca489bc897ab378b9">le_cfg_DeleteNode</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted.</p>
<p>If the path is empty, then the iterator's current node is deleted.</p>
<p>This function is only valid during a write transaction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3898fcb0d62b03c9a238d36b42d7a63"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetBool" ref="aa3898fcb0d62b03c9a238d36b42d7a63" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, bool defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#aa3898fcb0d62b03c9a238d36b42d7a63">le_cfg_GetBool</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a value from the tree as a boolean. If the node is empty or doesn't exist then the default value is returned. The default value is also returned if the node is of a different type than expected.</p>
<p>This function is valid for both read and write transactions.</p>
<p>If the path is empty, then the iterator's current node will be read. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb213c2fbf840931ec8c1427ef6b317e"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetFloat" ref="aeb213c2fbf840931ec8c1427ef6b317e" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, double defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="le__cfg__interface_8h.html#aeb213c2fbf840931ec8c1427ef6b317e">le_cfg_GetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a 64-bit floating point value from the configuration tree.</p>
<p>If the value is an integer then the value will be promoted to a float. Otherwise, if the underlying value is not a float or integer, the default value will be returned.</p>
<p>If the path is empty, then the iterator's current node will be read. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada4b5ea73868f3d00701d7e76c2e6f38"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetInt" ref="ada4b5ea73868f3d00701d7e76c2e6f38" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, int32_t defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="le__cfg__interface_8h.html#ada4b5ea73868f3d00701d7e76c2e6f38">le_cfg_GetInt</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a signed integer value from the configuration tree.</p>
<p>If the underlying value is not an integer, the default value will be returned instead. The default value is also returned if the node does not exist or if it's empty.</p>
<p>If the value is a floating point value, then it will be rounded and returned as an integer.</p>
<p>This function is valid for both read and write transactions.</p>
<p>If the path is empty, then the iterator's current node will be read. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02c84283bc9c62a490e9c7cf3f3d5598"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetNodeName" ref="a02c84283bc9c62a490e9c7cf3f3d5598" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, char *name, size_t nameNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a02c84283bc9c62a490e9c7cf3f3d5598">le_cfg_GetNodeName</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nameNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the node where the iterator is currently pointing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK Read was completed successfully.<ul>
<li>LE_OVERFLOW Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Read the name of the node object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31df1f796da5a18a74de1110c549d6f8"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetNodeType" ref="a31df1f796da5a18a74de1110c549d6f8" args="(le_cfg_IteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_nodeType_t <a class="el" href="le__cfg__interface_8h.html#a31df1f796da5a18a74de1110c549d6f8">le_cfg_GetNodeType</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the type of node where the iterator is currently pointing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>le_cfg_nodeType_t value indicating the stored value. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0c67c75671a9d003fa639b5f2ada51f"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetPath" ref="ab0c67c75671a9d003fa639b5f2ada51f" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, char *pathBuffer, size_t pathBufferNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#ab0c67c75671a9d003fa639b5f2ada51f">le_cfg_GetPath</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pathBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pathBufferNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get path to the node where the iterator is currently pointed.</p>
<p>Assuming the following tree:</p>
<div class="fragment"><pre class="fragment">  baseNode/
    childA/
      valueA
      valueB
</pre></div><p>If the iterator was currently pointing at valueA, GetPath would return the following path:</p>
<div class="fragment"><pre class="fragment">  /baseNode/childA/valueA
</pre></div><p>Optionally, a path to another node can be supplied to this function. So, if the iterator is again on valueA and the relative path ".." is supplied then this function will return the following path:</p>
<div class="fragment"><pre class="fragment">  /baseNode/childA/
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - The write was completed successfully.<ul>
<li>LE_OVERFLOW - The supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathBuffer</td><td>Absolute path to the iterator's current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathBufferNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabb24e6c90309be03ce5a285d5849658"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetString" ref="aabb24e6c90309be03ce5a285d5849658" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, char *value, size_t valueNumElements, const char *defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#aabb24e6c90309be03ce5a285d5849658">le_cfg_GetString</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a string value from the configuration tree. If the value isn't a string, or if the node is empty or doesn't exist then the default value will be returned.</p>
<p>This function is valid for both read and write transactions.</p>
<p>If the path is empty, then the iterator's current node will be read.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Read was completed successfully.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Buffer to write the value into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueNumElements</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb7ab8d52ca9bf5e0977341e18740079"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToFirstChild" ref="abb7ab8d52ca9bf5e0977341e18740079" args="(le_cfg_IteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#abb7ab8d52ca9bf5e0977341e18740079">le_cfg_GoToFirstChild</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the iterator to the the first child of the node where the iterator is currently pointed.</p>
<p>For read iterators without children, this function will fail. If the iterator is a write iterator, then a new node is automatically created. If this node or newly created children of this node are not written to, then this node will not persist even if the iterator is comitted.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return code will be one of the following values:</dd></dl>
<ul>
<li>LE_OK - Move was completed successfully.</li>
<li>LE_NOT_FOUND - The given node has no children. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafcdb4bf55c14d960b7d16bb05af4bbe"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToNextSibling" ref="aafcdb4bf55c14d960b7d16bb05af4bbe" args="(le_cfg_IteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#aafcdb4bf55c14d960b7d16bb05af4bbe">le_cfg_GoToNextSibling</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Jump the iterator to the next child node of the current node. Assuming the following tree:</p>
<div class="fragment"><pre class="fragment">  baseNode/
    childA/
      valueA
      valueB
</pre></div><p>If the iterator is moved to the path, "/baseNode/childA/valueA". After the first GoToNextSibling the iterator will be pointing at valueB. A second call to GoToNextSibling will cause the function to return LE_NOT_FOUND.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns one of the following values:</dd></dl>
<ul>
<li>LE_OK - Commit was completed successfully.</li>
<li>LE_NOT_FOUND - Iterator has reached the end of the current list of siblings. Also returned if the the current node has no siblings. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a8519b471bc6f4a5fea3716636dc607"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToNode" ref="a3a8519b471bc6f4a5fea3716636dc607" args="(le_cfg_IteratorRef_t iteratorRef, const char *newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a3a8519b471bc6f4a5fea3716636dc607">le_cfg_GoToNode</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the node that the iterator is pointing to. The path passed can be an absolute or a relative path from the iterators current location.</p>
<p>The target node does not need to exist. When a write iterator is used to go to a non-existant node, the node is automaticly created when a value is written to it or any of it's children. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Absolute or relative path from the current location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7d7debfc7c78b3a8b3908fcbc1a5966"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToParent" ref="ad7d7debfc7c78b3a8b3908fcbc1a5966" args="(le_cfg_IteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#ad7d7debfc7c78b3a8b3908fcbc1a5966">le_cfg_GoToParent</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the iterator to the parent of the node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return code will be one of the following values:</dd></dl>
<ul>
<li>LE_OK - Commit was completed successfully.</li>
<li>LE_NOT_FOUND - Current node is the root node: has no parent. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46db89aea45bb59128fba40bde081833"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_IsEmpty" ref="a46db89aea45bb59128fba40bde081833" args="(le_cfg_IteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#a46db89aea45bb59128fba40bde081833">le_cfg_IsEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the given node is empty. A node is also considered empty if it doesn't yet exist. A node is also considered empty if it has no value or is a stem with no children.</p>
<p>If the path is empty, then the iterator's current node is queried for emptiness.</p>
<p>This function is valid for both read and write transactions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A true if the node is considered empty, false if not. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33d4fbe741e6a6ff5377f60e8754d1e4"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_NodeExists" ref="a33d4fbe741e6a6ff5377f60e8754d1e4" args="(le_cfg_IteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#a33d4fbe741e6a6ff5377f60e8754d1e4">le_cfg_NodeExists</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to see if a given node in the configuration tree exists.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the specified node exists in the tree. False if not. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95f44c1e0d16eb48475465af63300a75"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickDeleteNode" ref="a95f44c1e0d16eb48475465af63300a75" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a95f44c1e0d16eb48475465af63300a75">le_cfg_QuickDeleteNode</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the node to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a256c22a1fbe25c69a96af37d388c6805"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetBool" ref="a256c22a1fbe25c69a96af37d388c6805" args="(const char *path, bool defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#a256c22a1fbe25c69a96af37d388c6805">le_cfg_QuickGetBool</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a value from the tree as a boolean. If the node is empty or doesn't exist then the default value is returned. This is also true if the node is of a different type than expected.</p>
<p>If the value is empty or the node doesn't exist then the default value is returned instead. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf4ccdd3b7b18b971768db755b8273fc"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetFloat" ref="acf4ccdd3b7b18b971768db755b8273fc" args="(const char *path, double defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="le__cfg__interface_8h.html#acf4ccdd3b7b18b971768db755b8273fc">le_cfg_QuickGetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a 64-bit floating point value from the configuration tree. If the value is an integer, then it is promoted to a float. Otherwise, if the underlying value is not a float, or an integer the default value will be returned.</p>
<p>If the value is empty or the node doesn't exist then the default value is returned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4503bb519a439f3de35d762668947c45"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetInt" ref="a4503bb519a439f3de35d762668947c45" args="(const char *path, int32_t defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="le__cfg__interface_8h.html#a4503bb519a439f3de35d762668947c45">le_cfg_QuickGetInt</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a signed integer value from the configuration tree. If the value is a floating point value, then it will be rounded and returned as an integer. Otherwise If the underlying value is not an integer or a float, the default value will be returned instead.</p>
<p>If the value is empty or the node doesn't exist then the default value is returned instead. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a049b354def8c343930816fd79903e483"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetString" ref="a049b354def8c343930816fd79903e483" args="(const char *path, char *value, size_t valueNumElements, const char *defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a049b354def8c343930816fd79903e483">le_cfg_QuickGetString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a string value from the configuration tree. If the value isn't a string, or if the node is empty or doesn't exist then the default value will be returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfully.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value read from the requested node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueNumElements</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The default value to use if the original can not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8915472ac5e82a8d3942ae8203264f2"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetBool" ref="ad8915472ac5e82a8d3942ae8203264f2" args="(const char *path, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#ad8915472ac5e82a8d3942ae8203264f2">le_cfg_QuickSetBool</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a boolean value to the configuration tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8fd42cad37a0a5d3ad8072b9571cc97"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetEmpty" ref="ae8fd42cad37a0a5d3ad8072b9571cc97" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#ae8fd42cad37a0a5d3ad8072b9571cc97">le_cfg_QuickSetEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a given node empty. If the node doesn't currently exist then it is created as a new empty node. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea4e34e0d4384f3cf0bb1c3bd27d4133"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetFloat" ref="aea4e34e0d4384f3cf0bb1c3bd27d4133" args="(const char *path, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#aea4e34e0d4384f3cf0bb1c3bd27d4133">le_cfg_QuickSetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a 64-bit floating point value to the configuration tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca19ad4032442eb97171769e434d3a60"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetInt" ref="aca19ad4032442eb97171769e434d3a60" args="(const char *path, int32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#aca19ad4032442eb97171769e434d3a60">le_cfg_QuickSetInt</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a signed integer value to the configuration tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebf43c4763e9e9d9b305200ace67fdac"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetString" ref="aebf43c4763e9e9d9b305200ace67fdac" args="(const char *path, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#aebf43c4763e9e9d9b305200ace67fdac">le_cfg_QuickSetString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a string value to the configuration tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17fa5e63dd1f5a2b7b66c92a76f8c98a"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_RemoveChangeHandler" ref="a17fa5e63dd1f5a2b7b66c92a76f8c98a" args="(le_cfg_ChangeHandlerRef_t addHandlerRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a17fa5e63dd1f5a2b7b66c92a76f8c98a">le_cfg_RemoveChangeHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td>
          <td class="paramname"><em>addHandlerRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>le_cfg_ChangeHandler handler REMOVE function </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addHandlerRef</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b760f2ef78e9c12dc207a5cbe333c99"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetBool" ref="a1b760f2ef78e9c12dc207a5cbe333c99" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a1b760f2ef78e9c12dc207a5cbe333c99">le_cfg_SetBool</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a boolean value to the configuration tree. This function is only valid during a write transaction.</p>
<p>If the path is empty, then the iterator's current node will be set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a008c17822f0af91639b1fbb257be48ea"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetEmpty" ref="a008c17822f0af91639b1fbb257be48ea" args="(le_cfg_IteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a008c17822f0af91639b1fbb257be48ea">le_cfg_SetEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear out the nodes's value. If it doesn't exist it will be created, but have no value.</p>
<p>If the path is empty, then the iterator's current node will be cleared. If the node is a stem then all children will be removed from the tree.</p>
<p>This function is only valid during a write transaction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab1e755f81ef2e4bcbc6d57ea558a7a5"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetFloat" ref="aab1e755f81ef2e4bcbc6d57ea558a7a5" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#aab1e755f81ef2e4bcbc6d57ea558a7a5">le_cfg_SetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a 64-bit floating point value to the configuration tree. This function is only valid during a write transaction.</p>
<p>If the path is empty, then the iterator's current node will be set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46cb4c6dd1068cb07128ca637667bb77"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetInt" ref="a46cb4c6dd1068cb07128ca637667bb77" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, int32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a46cb4c6dd1068cb07128ca637667bb77">le_cfg_SetInt</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a signed integer value to the configuration tree. This function is only valid during a write transaction.</p>
<p>If the path is empty, then the iterator's current node will be set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8802d20de7b178e51191c20e74fb495b"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetNodeName" ref="a8802d20de7b178e51191c20e74fb495b" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a8802d20de7b178e51191c20e74fb495b">le_cfg_SetNodeName</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the name of the node that the iterator is currently pointing at.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>LE_OK Write was completed successfully.</li>
<li>LE_FORMAT_ERROR The new name included illegial characters, '/' or used one of the reserved names: '.', or '..'. Format error is also returned if the new name is NULL or empty.</li>
<li>LE_DUPLICATE If there is another node with the new name in the same collection. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>New name for the node object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a741ade500cc7b10070e45065740d6980"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetString" ref="a741ade500cc7b10070e45065740d6980" args="(le_cfg_IteratorRef_t iteratorRef, const char *path, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a741ade500cc7b10070e45065740d6980">le_cfg_SetString</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_IteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a string value to the configuration tree. This function is only valid during a write transaction.</p>
<p>If the path is empty, then the iterator's current node will be set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5228a4832c56fbec5a6448db814d6a49"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_StartClient" ref="a5228a4832c56fbec5a6448db814d6a49" args="(const char *serviceInstanceName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a5228a4832c56fbec5a6448db814d6a49">le_cfg_StartClient</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceInstanceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the service for the client main thread </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">serviceInstanceName</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04d4fcfe495fe8ff73e7b1bfe9a034a0"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_StopClient" ref="a04d4fcfe495fe8ff73e7b1bfe9a034a0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a04d4fcfe495fe8ff73e7b1bfe9a034a0">le_cfg_StopClient</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the service for the current client thread </p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="le__cfg__interface_8h.html">le_cfg_interface.h</a>      </li>
   <div class="footer">
        <div>
            <a href="http://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.7.6.1
        </div>
    </div>
</body>
</html>
