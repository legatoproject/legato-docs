<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: C Language Coding Standards</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Wireless M2M smooth and connected</div>
  </td>
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ccoding_stds_main.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">C Language Coding Standards </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Legato follows these C language standards to aid in simplifying coding and help in code reuse.</p>
<p>General standards (in alpha order):</p>
<p><a class="el" href="ccoding_stds_main.html#cstdsparamCommenting">Commenting</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsConstPointers">Const Pointers</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsCyclomatic">Cyclomatic Complexity</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsExistingCode">Existing Code</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsExtern">Extern</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsFanOut">Fan Out</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsFunctionParameter">Function Parameters</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsGlobalVariables">Global Variables</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsGotos">Gotos</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsHeap">Heap</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsInterfaceDocumentation">Interface Documentation</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsLineLength">Line Length</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsMultipleInclusionGuards">Multiple Inclusion Guards</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsMultithreading">Multithreading</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsRecursion">Recursion</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsSeparateInterfacefromImplementation">Separating Interface from Implementation</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsTabs">Tabs</a></p>
<p>Detailed info:</p>
<p><a class="el" href="ccoding_stds_naming.html">C Naming Standards</a> <br/>
 <a class="el" href="ccoding_stds_abbr.html">C Abbreviations</a> <br/>
</p>
<h2><a class="anchor" id="cstdsparamCommenting"></a>
Commenting</h2>
<p>If it's not completely obvious what's going on, it must be documented clearly using comments.</p>
<p>Comments should also be used to improve readability, wherever appropriate.</p>
<p>However, there's no point in commenting the obvious, like this: </p>
<div class="fragment"><pre class="fragment">
// Set the flag
isReady = TRUE; </pre></div><p>Comments should focus mainly on describing why something is happening, rather than what or how. Code should be written so that what it's doing, and how it's doing it, is obvious (because of the well named identifiers and cleanly structured code). If not, your should probably rewrite the code. If that's not practical, then you should comment on what and how.</p>
<p>The idea of why the code is doing what it's doing can't be conveyed well in the code itself. This is the most valuable information to have in comments to advise of pitfalls and help quickly identify whether design change options are viable. Often, the ''why'' was learned the hard way, so documenting it can save others from having to learn it the hard way, too. Also, sometimes things are done arbitrarily, which is good to know too so people don't have to fear that making changes to it might break something in some subtle way.</p>
<p>C++ style comments are permitted in C code. All modern compilers support them.</p>
<p>Each module should contain a comment block at the top of the file that describes the module's purpose. The header comment block should be formatted like this:</p>
<div class="fragment"><pre class="fragment">
/**
 * @file le_basics.h
 *
 * There are certain cardinal types and commonly-used constants that form the most basic
 * foundation upon which everything else is built.  These include things such as
 * error codes, portable integer types, and helpful macros to make ugly things nicer to look
 * at and easier to use.
 *
 * &lt;HR&gt;
 *
 * Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license.
 */
</pre></div><p>Each function should be preceded by a comment block that describes the purpose of the function, its possible return values, and any side effects it may have. The function blocks should be formatted like this:</p>
<div class="fragment"><pre class="fragment">
//--------------------------------------------------------------------------------------------------
/**
 * Creates a sub-pool.
 * 
 * See @ref sub_pools for more information.
 * 
 * @return
 *      A reference to the sub-pool.
 */
//--------------------------------------------------------------------------------------------------
le_mem_PoolRef_t le_mem_CreateSubPool
(
    le_mem_PoolRef_t    pool,       ///&lt; [IN] The super-pool.
    const char*         name,       ///&lt; [IN] Name of the sub-pool (will be copied into the
                                    ///   sub-pool).
    size_t              numObjects  ///&lt; [IN] Number of objects to take from the super-pool.
);
</pre></div><p>Function parameters should be documented with comments after the parameter like above. Placing the comments after the parameters (instead of in the function comment block) keeps the comments and parameters together making it easier to read. It also reminds the developer to update the comments when the parameters are changed.</p>
<p>A struct should be documented in a similar manner where each field has comments proceeding it like this:</p>
<div class="fragment"><pre class="fragment">
//--------------------------------------------------------------------------------------------------
/**
 * List of memory pool statistics.
 */
//--------------------------------------------------------------------------------------------------
typedef struct
{
    uint64_t    numAllocs;      ///&lt; Number of times an object has been allocated from this pool.
    size_t      numFree;        ///&lt; Number of free objects currently available in this pool.
    size_t      numOverflows;   ///&lt; Number of times le_mem_ForceAlloc() had to expand the pool.
}
le_mem_PoolStats_t;
</pre></div><p>Enumerated types should be documented similarly.</p>
<div class="fragment"><pre class="fragment">
//--------------------------------------------------------------------------------------------------
/**
 * Standard result codes.
 * 
 * @note All error codes are negative integers that allows functions returning signed
 *       integers to return non-negative values when successful or standard error codes on failure.
 */
//--------------------------------------------------------------------------------------------------
typedef enum
{
    LE_OK = 0,              ///&lt; Successful.
    LE_NOT_FOUND = -1,      ///&lt; Referenced item does not exist or could not be found.
    LE_NOT_POSSIBLE = -2,   ///&lt; Not possible to perform the requested action. 
    LE_OUT_OF_RANGE = -3,   ///&lt; An index or other value is out of range.
    LE_NO_MEMORY = -4,      ///&lt; Insufficient memory is available.
    LE_NOT_PERMITTED = -5,  ///&lt; Current user does not have permission to perform requested action.
    LE_FAULT = -6,          ///&lt; Unspecified internal error.
    LE_COMM_ERROR = -7,     ///&lt; Communications error.
    LE_TIMEOUT = -8,        ///&lt; Time-out occurred.
    LE_OVERFLOW = -9,       ///&lt; Overflow occurred or would have occurred.
    LE_WOULD_BLOCK = -10,   ///&lt; Would have blocked if non-blocking behaviour was not requested.
}
le_result_t;
</pre></div><p>If the meaning of the constants in an enumerated type are obvious based on their names, comments could be omitted like this:</p>
<div class="fragment"><pre class="fragment">
//--------------------------------------------------------------------------------------------------
/**
 * Boolean type.
 * 
 * 0 is false and 1 is true, in keeping with the C programming language's
 * Boolean expression evaluation rules.
 */
//--------------------------------------------------------------------------------------------------
typedef enum
{
    FALSE = 0,
    TRUE = 1
}
bool;
</pre></div><h2><a class="anchor" id="cstdsConstPointers"></a>
Const Pointers</h2>
<p>Pointer type function parameters must be declared <code>const</code> if the object pointed to will not be modified by the function being passed.</p>
<p>Pointer type return values must be declared <code>const</code> if the object being returned must not be modified by the caller.</p>
<h2><a class="anchor" id="cstdsCyclomatic"></a>
Cyclomatic Complexity</h2>
<p><a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity/Cyclomatic">http://en.wikipedia.org/wiki/Cyclomatic_complexity/Cyclomatic</a> complexity is a measurement of the complexity of code within a function. It's measured by counting branches within a function.</p>
<p>Each function gets a starting value of 1, and 1 is added for every "if" (or "?"), every loop (for, do, or while), and every "case".</p>
<p>The following code has a cyclomatic complexity of 3:</p>
<div class="fragment"><pre class="fragment">
int main(int argc, char** argv)
{
    int i;
    int result = 0;

    if (argc &lt;= 0)
    {
        printf("No arguments provided.\n");
        result = 1;
    }
    else
    {
        printf("argc = %d\n", argc);

        for (i = 0; i &lt; argc; i++)
        {
            printf("argv[%d] = '%s'\n", argv[i]);
        }
    }
    return result;
}
</pre></div><p>Higher levels of cyclomatic complexity are correlated with higher defect density.</p>
<p>All functions should have a cyclomatic complexity of 10 or less.</p>
<p>All functions must have a cyclomatic complexity of less than 15.</p>
<h2><a class="anchor" id="cstdsExistingCode"></a>
Existing Code</h2>
<p>When modifying previously written code, the pre-existing style should be used over the Legato standards. But you should apply the Legato standards to the parts you modify unless you're making a very small change.</p>
<h2><a class="anchor" id="cstdsExtern"></a>
Extern</h2>
<p>When global variables aren't used and all inter-module interfaces are defined in header files, the extern keyword isn't needed; don't use it. Using extern indicates poor coding practices.</p>
<h2><a class="anchor" id="cstdsFanOut"></a>
Fan Out</h2>
<p>Fan-out measures the number of different functions called by a function including the number of data structures it updates. High levels of fan-out indicate insufficient abstraction and results in higher defect density.</p>
<p>The following function has a fan-out of 5: </p>
<div class="fragment"><pre class="fragment">
static int Log(int value)
{
    if (IsAboveThreshold(value))
    {
        LogEntry_t* entryPtr = AllocEntry();
        if (entryPtr == NULL)
        {
            ReportError("Out of memory!");
        }
        else
        {
            entryPtr-&gt;value = value;
            entryPtr-&gt;timestamp = GetTimestamp();

            // Add the entry to the log entry list.
            LogEntryList[NextEntryIndex++] = entryPtr;
            if (NextExtryIndex &gt;= LOG_SIZE)
            {
                NextEntryIndex = 0; // wrap around
            }
            if (NextEntryIndex == LastEntryIndex)
            {
                ReportError("Log overflow! Log entry discarded.");
                LastEntryIndex = (LastEntryIndex + 1) % LOG_SIZE;
            }
        }
    }
}

</pre></div><p>The functions IsAboveThreshold(), AllocEntry(), ReportError(), and GetTimestamp() are called by the Log() function. The "Log" data structure (consisting of the variables LogEntryList, NextEntryIndex, and LastEntryIndex) is updated by the Log() function. The second and subsequent calls to the same function are not counted. Even though ReportError() is called twice by Log(), it only contributes 1 to the fan-out.</p>
<p>Ideally, fan-out should be kept to 7 or less, and must be kept to 10 or less.</p>
<h2><a class="anchor" id="cstdsFunctionParameter"></a>
Function Parameters</h2>
<p>The number of parameters passed to a function should be kept as low as possible. Functions with less parameters tend to be easier to understand and easier to use. C functions should have 3 parameters or less.</p>
<h2><a class="anchor" id="cstdsGlobalVariables"></a>
Global Variables</h2>
<p>Global variables are variables that are exported to other modules (i.e., have a scope that spans multiple files).</p>
<p>Global variables are dangerous because they don't protect from multithreaded race conditions, and they reduce maintainability because of the increased coupling.</p>
<p>Globals must not be used. Use accessor functions instead.</p>
<p>NOTE: file-scope static variables are fine.</p>
<h2><a class="anchor" id="cstdsGotos"></a>
Gotos</h2>
<p><code>goto</code> statements should not be used. It it's absolutely essential, use them sparingly only as a jump-to-exception-handling mechanism:</p>
<div class="fragment"><pre class="fragment">
{
    Rec_t* recPtr = CreateRec();

    ...

    if (x &gt; LIMIT)
    {
        goto fault;
    }

    ...

    SaveRec(recPtr);
    return SUCCESS;

fault:

    ReleaseRec(recPtr);
    return FAILED;
}

</pre></div><h2><a class="anchor" id="cstdsHeap"></a>
Heap</h2>
<p>Depending on the algorithm used, dynamic memory allocation using a memory heap (e.g., malloc, free, and variants like calloc, realloc, and strdup) can lead to heap fragmentation resulting in unexpected runtime failures. And heap allocation and deallocation can be very slow in some cases.</p>
<p>Use memory pools instead. Memory pools eliminate internal fragmentation, run in O(1) time (for both allocation and deallocation), can be named for diagnostics purposes, allow finer-grained memory allocation statistics collection, and can provide OO constructor and destructor functionality.</p>
<h2><a class="anchor" id="cstdsInterfaceDocumentation"></a>
Interface Documentation</h2>
<p>Inter-component interfaces should be documented using Doxygen. This ensures documentation is inside the include (.h) files.</p>
<h2><a class="anchor" id="cstdsLineLength"></a>
Line Length</h2>
<p>Lines of code should not be longer than 100 columns.</p>
<h2><a class="anchor" id="cstdsMultipleInclusionGuards"></a>
Multiple Inclusion Guards</h2>
<p>To prevent declaration errors due to multiple inclusion of the same header file, every header file must include a "multiple inclusion guard" like this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef UNIQUE_INCLUDE_GUARD</span>
<span class="preprocessor"></span><span class="preprocessor">#define UNIQUE_INCLUDE_GUARD</span>
<span class="preprocessor"></span>
...

#endif
</pre></div><p><code>UNIQUE_INCLUDE_GUARD</code> must be replaced with a macro name unique to this header file. To ensure uniqueness, the macro name should:</p>
<ul>
<li>contain the name of the file (converted to all upper case, with underscores separating words)</li>
<li>be prefixed with a name or abbreviation that's unique to the module that the header file is a part of</li>
<li>have "_INCLUDE_GUARD" as a suffix.</li>
</ul>
<p>The Converter module's inter-module interface file converter.h' in the Sierra Wireless (SWI) Transmogrifier component could contain a multiple inclusion guard macro named like this: </p>
<div class="fragment"><pre class="fragment">SWI_TMOG_CONVERTER_INCLUDE_GUARD
</pre></div><p>Code in a header file must be inside the file's multiple inclusion guard (except for comments) like this:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Only comments allowed here.</span>

<span class="preprocessor">#ifndef SWI_TMOG_CONVERTER_INCLUDE_GUARD</span>
<span class="preprocessor"></span><span class="preprocessor">#define SWI_TMOG_CONVERTER_INCLUDE_GUARD</span>
<span class="preprocessor"></span>
<span class="comment">// Any code can go here.</span>

<span class="preprocessor">#endif // SWI_TMOG_CONVERTER_INCLUDE_GUARD</span>
<span class="preprocessor"></span>
<span class="comment">// Only comments allowed here, but preferably nothing but the end of file should be here.</span>
</pre></div><p>To allow include guard macros to be renamed (in case the file is renamed, the code changes hands, a naming conflict is found, etc.) and to avoid maintenance confusion, these macros shouldn't be used for anything else other than the multiple inclusion guard.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you're modifying existing code that uses multiple inclusion guard, follow the pre-existing code style instead of the Legato standard.</dd></dl>
<h2><a class="anchor" id="cstdsMultithreading"></a>
Multithreading</h2>
<p>Sometimes multithreading can be a powerful tool to allow functionally-related code be grouped into a single control flow where it would otherwise be fragmented into small chunks that can run without blocking. But multithreading can easily create some of the most nasty bugs.</p>
<p>What can we do in coding standards to help prevent bugs arising from multithreading? Perhaps defining how synchronization is performed? Can we have a standard macro definition for mutual exclusion for example? Maybe that's outside of what coding standards normally define, but it could be useful.</p>
<h2><a class="anchor" id="cstdsRecursion"></a>
Recursion</h2>
<p>Recursion can be dangerous because it can result in stack overruns. <b>Don't use recursion</b> unless you can clearly highlight the recursion and prove that the recursion will be bounded well within the limits of even the smallest stack space that could reasonably be allocated to your thread.</p>
<h2><a class="anchor" id="cstdsSeparateInterfacefromImplementation"></a>
Separating Interface from Implementation</h2>
<p>Header files should contain only interface details. Implementation details should appear only in <code></code>.c files.</p>
<p>Separating interface from implementation reduces coupling, which increases quality.</p>
<h2><a class="anchor" id="cstdsTabs"></a>
Tabs</h2>
<p>Tab characters are not handled in a consistent way in editors and browsers. Some put tab stops at the equivalent of 8 spaces, others use 4 or other variations. As a result, source code containing tab characters are not rendered properly in all cases.</p>
<p>Avoid tab characters avoided in C source code. Use spaces to indent lines instead.</p>
<p>The standard indentation distance is 4 spaces per indentation level.</p>
<p>Configure your editor(s) now! (...and, while you're at it, tell your editor not to automatically go and change pre-existing code.)</p>
<hr/>
<p>Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>
   <div class="footer">
        <div>
            <a href="http://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.7.6.1
        </div>
    </div>
</body>
</html>
